import { requestBuilder as rb } from "@smithy/core";
import { _json, collectBody, decorateServiceException as __decorateServiceException, expectBoolean as __expectBoolean, expectInt32 as __expectInt32, expectLong as __expectLong, expectNonNull as __expectNonNull, expectNumber as __expectNumber, expectObject as __expectObject, expectString as __expectString, limitedParseDouble as __limitedParseDouble, map, parseEpochTimestamp as __parseEpochTimestamp, serializeFloat as __serializeFloat, take, withBaseException, } from "@smithy/smithy-client";
import { v4 as generateIdempotencyToken } from "uuid";
import { IoTServiceException as __BaseException } from "../models/IoTServiceException";
import { CertificateStateException, CertificateValidationException, ConflictException, ConflictingResourceUpdateException, DeleteConflictException, IndexNotReadyException, InternalException, InternalFailureException, InternalServerException, InvalidAggregationException, InvalidQueryException, InvalidRequestException, InvalidStateTransitionException, LimitExceededException, MalformedPolicyException, ResourceAlreadyExistsException, ResourceNotFoundException, ServiceQuotaExceededException, ServiceUnavailableException, SqlParseException, ThrottlingException, TransferAlreadyCompletedException, UnauthorizedException, ValidationException, VersionConflictException, VersionsLimitExceededException, } from "../models/models_0";
import { NotConfiguredException, } from "../models/models_1";
import { CertificateConflictException, InvalidResponseException, RegistrationCodeValidationException, ResourceRegistrationFailureException, TaskAlreadyExistsException, TransferConflictException, } from "../models/models_2";
export const se_AcceptCertificateTransferCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/accept-certificate-transfer/{certificateId}");
    b.p("certificateId", () => input.certificateId, "{certificateId}", false);
    const query = map({
        [_sAA]: [() => input.setAsActive !== void 0, () => input[_sAA].toString()],
    });
    let body;
    b.m("PATCH").h(headers).q(query).b(body);
    return b.build();
};
export const se_AddThingToBillingGroupCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/billing-groups/addThingToBillingGroup");
    let body;
    body = JSON.stringify(take(input, {
        billingGroupArn: [],
        billingGroupName: [],
        thingArn: [],
        thingName: [],
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_AddThingToThingGroupCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/thing-groups/addThingToThingGroup");
    let body;
    body = JSON.stringify(take(input, {
        overrideDynamicGroups: [],
        thingArn: [],
        thingGroupArn: [],
        thingGroupName: [],
        thingName: [],
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_AssociateTargetsWithJobCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/jobs/{jobId}/targets");
    b.p("jobId", () => input.jobId, "{jobId}", false);
    const query = map({
        [_nI]: [, input[_nI]],
    });
    let body;
    body = JSON.stringify(take(input, {
        comment: [],
        targets: (_) => _json(_),
    }));
    b.m("POST").h(headers).q(query).b(body);
    return b.build();
};
export const se_AttachPolicyCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/target-policies/{policyName}");
    b.p("policyName", () => input.policyName, "{policyName}", false);
    let body;
    body = JSON.stringify(take(input, {
        target: [],
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_AttachPrincipalPolicyCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        [_xaip]: input[_p],
    });
    b.bp("/principal-policies/{policyName}");
    b.p("policyName", () => input.policyName, "{policyName}", false);
    let body;
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_AttachSecurityProfileCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/security-profiles/{securityProfileName}/targets");
    b.p("securityProfileName", () => input.securityProfileName, "{securityProfileName}", false);
    const query = map({
        [_sPTA]: [, __expectNonNull(input[_sPTA], `securityProfileTargetArn`)],
    });
    let body;
    b.m("PUT").h(headers).q(query).b(body);
    return b.build();
};
export const se_AttachThingPrincipalCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        [_xap]: input[_p],
    });
    b.bp("/things/{thingName}/principals");
    b.p("thingName", () => input.thingName, "{thingName}", false);
    let body;
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_CancelAuditMitigationActionsTaskCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/audit/mitigationactions/tasks/{taskId}/cancel");
    b.p("taskId", () => input.taskId, "{taskId}", false);
    let body;
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_CancelAuditTaskCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/audit/tasks/{taskId}/cancel");
    b.p("taskId", () => input.taskId, "{taskId}", false);
    let body;
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_CancelCertificateTransferCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/cancel-certificate-transfer/{certificateId}");
    b.p("certificateId", () => input.certificateId, "{certificateId}", false);
    let body;
    b.m("PATCH").h(headers).b(body);
    return b.build();
};
export const se_CancelDetectMitigationActionsTaskCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/detect/mitigationactions/tasks/{taskId}/cancel");
    b.p("taskId", () => input.taskId, "{taskId}", false);
    let body;
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_CancelJobCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/jobs/{jobId}/cancel");
    b.p("jobId", () => input.jobId, "{jobId}", false);
    const query = map({
        [_f]: [() => input.force !== void 0, () => input[_f].toString()],
    });
    let body;
    body = JSON.stringify(take(input, {
        comment: [],
        reasonCode: [],
    }));
    b.m("PUT").h(headers).q(query).b(body);
    return b.build();
};
export const se_CancelJobExecutionCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/things/{thingName}/jobs/{jobId}/cancel");
    b.p("jobId", () => input.jobId, "{jobId}", false);
    b.p("thingName", () => input.thingName, "{thingName}", false);
    const query = map({
        [_f]: [() => input.force !== void 0, () => input[_f].toString()],
    });
    let body;
    body = JSON.stringify(take(input, {
        expectedVersion: [],
        statusDetails: (_) => _json(_),
    }));
    b.m("PUT").h(headers).q(query).b(body);
    return b.build();
};
export const se_ClearDefaultAuthorizerCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/default-authorizer");
    let body;
    body = "";
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_ConfirmTopicRuleDestinationCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/confirmdestination/{confirmationToken+}");
    b.p("confirmationToken", () => input.confirmationToken, "{confirmationToken+}", true);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_CreateAuditSuppressionCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/audit/suppressions/create");
    let body;
    body = JSON.stringify(take(input, {
        checkName: [],
        clientRequestToken: [true, (_) => _ ?? generateIdempotencyToken()],
        description: [],
        expirationDate: (_) => Math.round(_.getTime() / 1000),
        resourceIdentifier: (_) => _json(_),
        suppressIndefinitely: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateAuthorizerCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/authorizer/{authorizerName}");
    b.p("authorizerName", () => input.authorizerName, "{authorizerName}", false);
    let body;
    body = JSON.stringify(take(input, {
        authorizerFunctionArn: [],
        enableCachingForHttp: [],
        signingDisabled: [],
        status: [],
        tags: (_) => _json(_),
        tokenKeyName: [],
        tokenSigningPublicKeys: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateBillingGroupCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/billing-groups/{billingGroupName}");
    b.p("billingGroupName", () => input.billingGroupName, "{billingGroupName}", false);
    let body;
    body = JSON.stringify(take(input, {
        billingGroupProperties: (_) => _json(_),
        tags: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateCertificateFromCsrCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/certificates");
    const query = map({
        [_sAA]: [() => input.setAsActive !== void 0, () => input[_sAA].toString()],
    });
    let body;
    body = JSON.stringify(take(input, {
        certificateSigningRequest: [],
    }));
    b.m("POST").h(headers).q(query).b(body);
    return b.build();
};
export const se_CreateCertificateProviderCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/certificate-providers/{certificateProviderName}");
    b.p("certificateProviderName", () => input.certificateProviderName, "{certificateProviderName}", false);
    let body;
    body = JSON.stringify(take(input, {
        accountDefaultForOperations: (_) => _json(_),
        clientToken: [true, (_) => _ ?? generateIdempotencyToken()],
        lambdaFunctionArn: [],
        tags: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateCustomMetricCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/custom-metric/{metricName}");
    b.p("metricName", () => input.metricName, "{metricName}", false);
    let body;
    body = JSON.stringify(take(input, {
        clientRequestToken: [true, (_) => _ ?? generateIdempotencyToken()],
        displayName: [],
        metricType: [],
        tags: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateDimensionCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/dimensions/{name}");
    b.p("name", () => input.name, "{name}", false);
    let body;
    body = JSON.stringify(take(input, {
        clientRequestToken: [true, (_) => _ ?? generateIdempotencyToken()],
        stringValues: (_) => _json(_),
        tags: (_) => _json(_),
        type: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateDomainConfigurationCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/domainConfigurations/{domainConfigurationName}");
    b.p("domainConfigurationName", () => input.domainConfigurationName, "{domainConfigurationName}", false);
    let body;
    body = JSON.stringify(take(input, {
        authorizerConfig: (_) => _json(_),
        domainName: [],
        serverCertificateArns: (_) => _json(_),
        serviceType: [],
        tags: (_) => _json(_),
        tlsConfig: (_) => _json(_),
        validationCertificateArn: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateDynamicThingGroupCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/dynamic-thing-groups/{thingGroupName}");
    b.p("thingGroupName", () => input.thingGroupName, "{thingGroupName}", false);
    let body;
    body = JSON.stringify(take(input, {
        indexName: [],
        queryString: [],
        queryVersion: [],
        tags: (_) => _json(_),
        thingGroupProperties: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateFleetMetricCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/fleet-metric/{metricName}");
    b.p("metricName", () => input.metricName, "{metricName}", false);
    let body;
    body = JSON.stringify(take(input, {
        aggregationField: [],
        aggregationType: (_) => _json(_),
        description: [],
        indexName: [],
        period: [],
        queryString: [],
        queryVersion: [],
        tags: (_) => _json(_),
        unit: [],
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_CreateJobCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/jobs/{jobId}");
    b.p("jobId", () => input.jobId, "{jobId}", false);
    let body;
    body = JSON.stringify(take(input, {
        abortConfig: (_) => se_AbortConfig(_, context),
        description: [],
        destinationPackageVersions: (_) => _json(_),
        document: [],
        documentParameters: (_) => _json(_),
        documentSource: [],
        jobExecutionsRetryConfig: (_) => _json(_),
        jobExecutionsRolloutConfig: (_) => se_JobExecutionsRolloutConfig(_, context),
        jobTemplateArn: [],
        namespaceId: [],
        presignedUrlConfig: (_) => _json(_),
        schedulingConfig: (_) => _json(_),
        tags: (_) => _json(_),
        targetSelection: [],
        targets: (_) => _json(_),
        timeoutConfig: (_) => _json(_),
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_CreateJobTemplateCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/job-templates/{jobTemplateId}");
    b.p("jobTemplateId", () => input.jobTemplateId, "{jobTemplateId}", false);
    let body;
    body = JSON.stringify(take(input, {
        abortConfig: (_) => se_AbortConfig(_, context),
        description: [],
        destinationPackageVersions: (_) => _json(_),
        document: [],
        documentSource: [],
        jobArn: [],
        jobExecutionsRetryConfig: (_) => _json(_),
        jobExecutionsRolloutConfig: (_) => se_JobExecutionsRolloutConfig(_, context),
        maintenanceWindows: (_) => _json(_),
        presignedUrlConfig: (_) => _json(_),
        tags: (_) => _json(_),
        timeoutConfig: (_) => _json(_),
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_CreateKeysAndCertificateCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/keys-and-certificate");
    const query = map({
        [_sAA]: [() => input.setAsActive !== void 0, () => input[_sAA].toString()],
    });
    let body;
    b.m("POST").h(headers).q(query).b(body);
    return b.build();
};
export const se_CreateMitigationActionCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/mitigationactions/actions/{actionName}");
    b.p("actionName", () => input.actionName, "{actionName}", false);
    let body;
    body = JSON.stringify(take(input, {
        actionParams: (_) => _json(_),
        roleArn: [],
        tags: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateOTAUpdateCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/otaUpdates/{otaUpdateId}");
    b.p("otaUpdateId", () => input.otaUpdateId, "{otaUpdateId}", false);
    let body;
    body = JSON.stringify(take(input, {
        additionalParameters: (_) => _json(_),
        awsJobAbortConfig: (_) => se_AwsJobAbortConfig(_, context),
        awsJobExecutionsRolloutConfig: (_) => se_AwsJobExecutionsRolloutConfig(_, context),
        awsJobPresignedUrlConfig: (_) => _json(_),
        awsJobTimeoutConfig: (_) => _json(_),
        description: [],
        files: (_) => se_OTAUpdateFiles(_, context),
        protocols: (_) => _json(_),
        roleArn: [],
        tags: (_) => _json(_),
        targetSelection: [],
        targets: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreatePackageCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/packages/{packageName}");
    b.p("packageName", () => input.packageName, "{packageName}", false);
    const query = map({
        [_cT]: [, input[_cT] ?? generateIdempotencyToken()],
    });
    let body;
    body = JSON.stringify(take(input, {
        description: [],
        tags: (_) => _json(_),
    }));
    b.m("PUT").h(headers).q(query).b(body);
    return b.build();
};
export const se_CreatePackageVersionCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/packages/{packageName}/versions/{versionName}");
    b.p("packageName", () => input.packageName, "{packageName}", false);
    b.p("versionName", () => input.versionName, "{versionName}", false);
    const query = map({
        [_cT]: [, input[_cT] ?? generateIdempotencyToken()],
    });
    let body;
    body = JSON.stringify(take(input, {
        attributes: (_) => _json(_),
        description: [],
        tags: (_) => _json(_),
    }));
    b.m("PUT").h(headers).q(query).b(body);
    return b.build();
};
export const se_CreatePolicyCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/policies/{policyName}");
    b.p("policyName", () => input.policyName, "{policyName}", false);
    let body;
    body = JSON.stringify(take(input, {
        policyDocument: [],
        tags: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreatePolicyVersionCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/policies/{policyName}/version");
    b.p("policyName", () => input.policyName, "{policyName}", false);
    const query = map({
        [_sAD]: [() => input.setAsDefault !== void 0, () => input[_sAD].toString()],
    });
    let body;
    body = JSON.stringify(take(input, {
        policyDocument: [],
    }));
    b.m("POST").h(headers).q(query).b(body);
    return b.build();
};
export const se_CreateProvisioningClaimCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/provisioning-templates/{templateName}/provisioning-claim");
    b.p("templateName", () => input.templateName, "{templateName}", false);
    let body;
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateProvisioningTemplateCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/provisioning-templates");
    let body;
    body = JSON.stringify(take(input, {
        description: [],
        enabled: [],
        preProvisioningHook: (_) => _json(_),
        provisioningRoleArn: [],
        tags: (_) => _json(_),
        templateBody: [],
        templateName: [],
        type: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateProvisioningTemplateVersionCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/provisioning-templates/{templateName}/versions");
    b.p("templateName", () => input.templateName, "{templateName}", false);
    const query = map({
        [_sAD]: [() => input.setAsDefault !== void 0, () => input[_sAD].toString()],
    });
    let body;
    body = JSON.stringify(take(input, {
        templateBody: [],
    }));
    b.m("POST").h(headers).q(query).b(body);
    return b.build();
};
export const se_CreateRoleAliasCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/role-aliases/{roleAlias}");
    b.p("roleAlias", () => input.roleAlias, "{roleAlias}", false);
    let body;
    body = JSON.stringify(take(input, {
        credentialDurationSeconds: [],
        roleArn: [],
        tags: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateScheduledAuditCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/audit/scheduledaudits/{scheduledAuditName}");
    b.p("scheduledAuditName", () => input.scheduledAuditName, "{scheduledAuditName}", false);
    let body;
    body = JSON.stringify(take(input, {
        dayOfMonth: [],
        dayOfWeek: [],
        frequency: [],
        tags: (_) => _json(_),
        targetCheckNames: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateSecurityProfileCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/security-profiles/{securityProfileName}");
    b.p("securityProfileName", () => input.securityProfileName, "{securityProfileName}", false);
    let body;
    body = JSON.stringify(take(input, {
        additionalMetricsToRetain: (_) => _json(_),
        additionalMetricsToRetainV2: (_) => _json(_),
        alertTargets: (_) => _json(_),
        behaviors: (_) => se_Behaviors(_, context),
        metricsExportConfig: (_) => _json(_),
        securityProfileDescription: [],
        tags: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateStreamCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/streams/{streamId}");
    b.p("streamId", () => input.streamId, "{streamId}", false);
    let body;
    body = JSON.stringify(take(input, {
        description: [],
        files: (_) => _json(_),
        roleArn: [],
        tags: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateThingCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/things/{thingName}");
    b.p("thingName", () => input.thingName, "{thingName}", false);
    let body;
    body = JSON.stringify(take(input, {
        attributePayload: (_) => _json(_),
        billingGroupName: [],
        thingTypeName: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateThingGroupCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/thing-groups/{thingGroupName}");
    b.p("thingGroupName", () => input.thingGroupName, "{thingGroupName}", false);
    let body;
    body = JSON.stringify(take(input, {
        parentGroupName: [],
        tags: (_) => _json(_),
        thingGroupProperties: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateThingTypeCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/thing-types/{thingTypeName}");
    b.p("thingTypeName", () => input.thingTypeName, "{thingTypeName}", false);
    let body;
    body = JSON.stringify(take(input, {
        tags: (_) => _json(_),
        thingTypeProperties: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateTopicRuleCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/json",
        [_xat]: input[_t],
    });
    b.bp("/rules/{ruleName}");
    b.p("ruleName", () => input.ruleName, "{ruleName}", false);
    let body;
    if (input.topicRulePayload !== undefined) {
        body = _json(input.topicRulePayload);
    }
    if (body === undefined) {
        body = {};
    }
    body = JSON.stringify(body);
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateTopicRuleDestinationCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/destinations");
    let body;
    body = JSON.stringify(take(input, {
        destinationConfiguration: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_DeleteAccountAuditConfigurationCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/audit/configuration");
    const query = map({
        [_dSA]: [() => input.deleteScheduledAudits !== void 0, () => input[_dSA].toString()],
    });
    let body;
    b.m("DELETE").h(headers).q(query).b(body);
    return b.build();
};
export const se_DeleteAuditSuppressionCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/audit/suppressions/delete");
    let body;
    body = JSON.stringify(take(input, {
        checkName: [],
        resourceIdentifier: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_DeleteAuthorizerCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/authorizer/{authorizerName}");
    b.p("authorizerName", () => input.authorizerName, "{authorizerName}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_DeleteBillingGroupCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/billing-groups/{billingGroupName}");
    b.p("billingGroupName", () => input.billingGroupName, "{billingGroupName}", false);
    const query = map({
        [_eV]: [() => input.expectedVersion !== void 0, () => input[_eV].toString()],
    });
    let body;
    b.m("DELETE").h(headers).q(query).b(body);
    return b.build();
};
export const se_DeleteCACertificateCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/cacertificate/{certificateId}");
    b.p("certificateId", () => input.certificateId, "{certificateId}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_DeleteCertificateCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/certificates/{certificateId}");
    b.p("certificateId", () => input.certificateId, "{certificateId}", false);
    const query = map({
        [_fD]: [() => input.forceDelete !== void 0, () => input[_fD].toString()],
    });
    let body;
    b.m("DELETE").h(headers).q(query).b(body);
    return b.build();
};
export const se_DeleteCertificateProviderCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/certificate-providers/{certificateProviderName}");
    b.p("certificateProviderName", () => input.certificateProviderName, "{certificateProviderName}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_DeleteCustomMetricCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/custom-metric/{metricName}");
    b.p("metricName", () => input.metricName, "{metricName}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_DeleteDimensionCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/dimensions/{name}");
    b.p("name", () => input.name, "{name}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_DeleteDomainConfigurationCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/domainConfigurations/{domainConfigurationName}");
    b.p("domainConfigurationName", () => input.domainConfigurationName, "{domainConfigurationName}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_DeleteDynamicThingGroupCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/dynamic-thing-groups/{thingGroupName}");
    b.p("thingGroupName", () => input.thingGroupName, "{thingGroupName}", false);
    const query = map({
        [_eV]: [() => input.expectedVersion !== void 0, () => input[_eV].toString()],
    });
    let body;
    b.m("DELETE").h(headers).q(query).b(body);
    return b.build();
};
export const se_DeleteFleetMetricCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/fleet-metric/{metricName}");
    b.p("metricName", () => input.metricName, "{metricName}", false);
    const query = map({
        [_eV]: [() => input.expectedVersion !== void 0, () => input[_eV].toString()],
    });
    let body;
    b.m("DELETE").h(headers).q(query).b(body);
    return b.build();
};
export const se_DeleteJobCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/jobs/{jobId}");
    b.p("jobId", () => input.jobId, "{jobId}", false);
    const query = map({
        [_f]: [() => input.force !== void 0, () => input[_f].toString()],
        [_nI]: [, input[_nI]],
    });
    let body;
    b.m("DELETE").h(headers).q(query).b(body);
    return b.build();
};
export const se_DeleteJobExecutionCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/things/{thingName}/jobs/{jobId}/executionNumber/{executionNumber}");
    b.p("jobId", () => input.jobId, "{jobId}", false);
    b.p("thingName", () => input.thingName, "{thingName}", false);
    b.p("executionNumber", () => input.executionNumber.toString(), "{executionNumber}", false);
    const query = map({
        [_f]: [() => input.force !== void 0, () => input[_f].toString()],
        [_nI]: [, input[_nI]],
    });
    let body;
    b.m("DELETE").h(headers).q(query).b(body);
    return b.build();
};
export const se_DeleteJobTemplateCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/job-templates/{jobTemplateId}");
    b.p("jobTemplateId", () => input.jobTemplateId, "{jobTemplateId}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_DeleteMitigationActionCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/mitigationactions/actions/{actionName}");
    b.p("actionName", () => input.actionName, "{actionName}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_DeleteOTAUpdateCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/otaUpdates/{otaUpdateId}");
    b.p("otaUpdateId", () => input.otaUpdateId, "{otaUpdateId}", false);
    const query = map({
        [_dS]: [() => input.deleteStream !== void 0, () => input[_dS].toString()],
        [_fDAWSJ]: [() => input.forceDeleteAWSJob !== void 0, () => input[_fDAWSJ].toString()],
    });
    let body;
    b.m("DELETE").h(headers).q(query).b(body);
    return b.build();
};
export const se_DeletePackageCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/packages/{packageName}");
    b.p("packageName", () => input.packageName, "{packageName}", false);
    const query = map({
        [_cT]: [, input[_cT] ?? generateIdempotencyToken()],
    });
    let body;
    b.m("DELETE").h(headers).q(query).b(body);
    return b.build();
};
export const se_DeletePackageVersionCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/packages/{packageName}/versions/{versionName}");
    b.p("packageName", () => input.packageName, "{packageName}", false);
    b.p("versionName", () => input.versionName, "{versionName}", false);
    const query = map({
        [_cT]: [, input[_cT] ?? generateIdempotencyToken()],
    });
    let body;
    b.m("DELETE").h(headers).q(query).b(body);
    return b.build();
};
export const se_DeletePolicyCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/policies/{policyName}");
    b.p("policyName", () => input.policyName, "{policyName}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_DeletePolicyVersionCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/policies/{policyName}/version/{policyVersionId}");
    b.p("policyName", () => input.policyName, "{policyName}", false);
    b.p("policyVersionId", () => input.policyVersionId, "{policyVersionId}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_DeleteProvisioningTemplateCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/provisioning-templates/{templateName}");
    b.p("templateName", () => input.templateName, "{templateName}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_DeleteProvisioningTemplateVersionCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/provisioning-templates/{templateName}/versions/{versionId}");
    b.p("templateName", () => input.templateName, "{templateName}", false);
    b.p("versionId", () => input.versionId.toString(), "{versionId}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_DeleteRegistrationCodeCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/registrationcode");
    let body;
    body = "";
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_DeleteRoleAliasCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/role-aliases/{roleAlias}");
    b.p("roleAlias", () => input.roleAlias, "{roleAlias}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_DeleteScheduledAuditCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/audit/scheduledaudits/{scheduledAuditName}");
    b.p("scheduledAuditName", () => input.scheduledAuditName, "{scheduledAuditName}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_DeleteSecurityProfileCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/security-profiles/{securityProfileName}");
    b.p("securityProfileName", () => input.securityProfileName, "{securityProfileName}", false);
    const query = map({
        [_eV]: [() => input.expectedVersion !== void 0, () => input[_eV].toString()],
    });
    let body;
    b.m("DELETE").h(headers).q(query).b(body);
    return b.build();
};
export const se_DeleteStreamCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/streams/{streamId}");
    b.p("streamId", () => input.streamId, "{streamId}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_DeleteThingCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/things/{thingName}");
    b.p("thingName", () => input.thingName, "{thingName}", false);
    const query = map({
        [_eV]: [() => input.expectedVersion !== void 0, () => input[_eV].toString()],
    });
    let body;
    b.m("DELETE").h(headers).q(query).b(body);
    return b.build();
};
export const se_DeleteThingGroupCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/thing-groups/{thingGroupName}");
    b.p("thingGroupName", () => input.thingGroupName, "{thingGroupName}", false);
    const query = map({
        [_eV]: [() => input.expectedVersion !== void 0, () => input[_eV].toString()],
    });
    let body;
    b.m("DELETE").h(headers).q(query).b(body);
    return b.build();
};
export const se_DeleteThingTypeCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/thing-types/{thingTypeName}");
    b.p("thingTypeName", () => input.thingTypeName, "{thingTypeName}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_DeleteTopicRuleCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/rules/{ruleName}");
    b.p("ruleName", () => input.ruleName, "{ruleName}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_DeleteTopicRuleDestinationCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/destinations/{arn+}");
    b.p("arn", () => input.arn, "{arn+}", true);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_DeleteV2LoggingLevelCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/v2LoggingLevel");
    const query = map({
        [_tT]: [, __expectNonNull(input[_tT], `targetType`)],
        [_tN]: [, __expectNonNull(input[_tN], `targetName`)],
    });
    let body;
    b.m("DELETE").h(headers).q(query).b(body);
    return b.build();
};
export const se_DeprecateThingTypeCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/thing-types/{thingTypeName}/deprecate");
    b.p("thingTypeName", () => input.thingTypeName, "{thingTypeName}", false);
    let body;
    body = JSON.stringify(take(input, {
        undoDeprecate: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_DescribeAccountAuditConfigurationCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/audit/configuration");
    let body;
    body = "";
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_DescribeAuditFindingCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/audit/findings/{findingId}");
    b.p("findingId", () => input.findingId, "{findingId}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_DescribeAuditMitigationActionsTaskCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/audit/mitigationactions/tasks/{taskId}");
    b.p("taskId", () => input.taskId, "{taskId}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_DescribeAuditSuppressionCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/audit/suppressions/describe");
    let body;
    body = JSON.stringify(take(input, {
        checkName: [],
        resourceIdentifier: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_DescribeAuditTaskCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/audit/tasks/{taskId}");
    b.p("taskId", () => input.taskId, "{taskId}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_DescribeAuthorizerCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/authorizer/{authorizerName}");
    b.p("authorizerName", () => input.authorizerName, "{authorizerName}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_DescribeBillingGroupCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/billing-groups/{billingGroupName}");
    b.p("billingGroupName", () => input.billingGroupName, "{billingGroupName}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_DescribeCACertificateCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/cacertificate/{certificateId}");
    b.p("certificateId", () => input.certificateId, "{certificateId}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_DescribeCertificateCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/certificates/{certificateId}");
    b.p("certificateId", () => input.certificateId, "{certificateId}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_DescribeCertificateProviderCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/certificate-providers/{certificateProviderName}");
    b.p("certificateProviderName", () => input.certificateProviderName, "{certificateProviderName}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_DescribeCustomMetricCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/custom-metric/{metricName}");
    b.p("metricName", () => input.metricName, "{metricName}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_DescribeDefaultAuthorizerCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/default-authorizer");
    let body;
    body = "";
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_DescribeDetectMitigationActionsTaskCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/detect/mitigationactions/tasks/{taskId}");
    b.p("taskId", () => input.taskId, "{taskId}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_DescribeDimensionCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/dimensions/{name}");
    b.p("name", () => input.name, "{name}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_DescribeDomainConfigurationCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/domainConfigurations/{domainConfigurationName}");
    b.p("domainConfigurationName", () => input.domainConfigurationName, "{domainConfigurationName}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_DescribeEndpointCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/endpoint");
    const query = map({
        [_eT]: [, input[_eT]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_DescribeEventConfigurationsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/event-configurations");
    let body;
    body = "";
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_DescribeFleetMetricCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/fleet-metric/{metricName}");
    b.p("metricName", () => input.metricName, "{metricName}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_DescribeIndexCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/indices/{indexName}");
    b.p("indexName", () => input.indexName, "{indexName}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_DescribeJobCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/jobs/{jobId}");
    b.p("jobId", () => input.jobId, "{jobId}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_DescribeJobExecutionCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/things/{thingName}/jobs/{jobId}");
    b.p("jobId", () => input.jobId, "{jobId}", false);
    b.p("thingName", () => input.thingName, "{thingName}", false);
    const query = map({
        [_eN]: [() => input.executionNumber !== void 0, () => input[_eN].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_DescribeJobTemplateCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/job-templates/{jobTemplateId}");
    b.p("jobTemplateId", () => input.jobTemplateId, "{jobTemplateId}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_DescribeManagedJobTemplateCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/managed-job-templates/{templateName}");
    b.p("templateName", () => input.templateName, "{templateName}", false);
    const query = map({
        [_tV]: [, input[_tV]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_DescribeMitigationActionCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/mitigationactions/actions/{actionName}");
    b.p("actionName", () => input.actionName, "{actionName}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_DescribeProvisioningTemplateCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/provisioning-templates/{templateName}");
    b.p("templateName", () => input.templateName, "{templateName}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_DescribeProvisioningTemplateVersionCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/provisioning-templates/{templateName}/versions/{versionId}");
    b.p("templateName", () => input.templateName, "{templateName}", false);
    b.p("versionId", () => input.versionId.toString(), "{versionId}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_DescribeRoleAliasCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/role-aliases/{roleAlias}");
    b.p("roleAlias", () => input.roleAlias, "{roleAlias}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_DescribeScheduledAuditCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/audit/scheduledaudits/{scheduledAuditName}");
    b.p("scheduledAuditName", () => input.scheduledAuditName, "{scheduledAuditName}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_DescribeSecurityProfileCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/security-profiles/{securityProfileName}");
    b.p("securityProfileName", () => input.securityProfileName, "{securityProfileName}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_DescribeStreamCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/streams/{streamId}");
    b.p("streamId", () => input.streamId, "{streamId}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_DescribeThingCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/things/{thingName}");
    b.p("thingName", () => input.thingName, "{thingName}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_DescribeThingGroupCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/thing-groups/{thingGroupName}");
    b.p("thingGroupName", () => input.thingGroupName, "{thingGroupName}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_DescribeThingRegistrationTaskCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/thing-registration-tasks/{taskId}");
    b.p("taskId", () => input.taskId, "{taskId}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_DescribeThingTypeCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/thing-types/{thingTypeName}");
    b.p("thingTypeName", () => input.thingTypeName, "{thingTypeName}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_DetachPolicyCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/target-policies/{policyName}");
    b.p("policyName", () => input.policyName, "{policyName}", false);
    let body;
    body = JSON.stringify(take(input, {
        target: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_DetachPrincipalPolicyCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        [_xaip]: input[_p],
    });
    b.bp("/principal-policies/{policyName}");
    b.p("policyName", () => input.policyName, "{policyName}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_DetachSecurityProfileCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/security-profiles/{securityProfileName}/targets");
    b.p("securityProfileName", () => input.securityProfileName, "{securityProfileName}", false);
    const query = map({
        [_sPTA]: [, __expectNonNull(input[_sPTA], `securityProfileTargetArn`)],
    });
    let body;
    b.m("DELETE").h(headers).q(query).b(body);
    return b.build();
};
export const se_DetachThingPrincipalCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        [_xap]: input[_p],
    });
    b.bp("/things/{thingName}/principals");
    b.p("thingName", () => input.thingName, "{thingName}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_DisableTopicRuleCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/rules/{ruleName}/disable");
    b.p("ruleName", () => input.ruleName, "{ruleName}", false);
    let body;
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_EnableTopicRuleCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/rules/{ruleName}/enable");
    b.p("ruleName", () => input.ruleName, "{ruleName}", false);
    let body;
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_GetBehaviorModelTrainingSummariesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/behavior-model-training/summaries");
    const query = map({
        [_sPN]: [, input[_sPN]],
        [_mR]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
        [_nT]: [, input[_nT]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_GetBucketsAggregationCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/indices/buckets");
    let body;
    body = JSON.stringify(take(input, {
        aggregationField: [],
        bucketsAggregationType: (_) => _json(_),
        indexName: [],
        queryString: [],
        queryVersion: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_GetCardinalityCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/indices/cardinality");
    let body;
    body = JSON.stringify(take(input, {
        aggregationField: [],
        indexName: [],
        queryString: [],
        queryVersion: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_GetEffectivePoliciesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/effective-policies");
    const query = map({
        [_tNh]: [, input[_tNh]],
    });
    let body;
    body = JSON.stringify(take(input, {
        cognitoIdentityPoolId: [],
        principal: [],
    }));
    b.m("POST").h(headers).q(query).b(body);
    return b.build();
};
export const se_GetIndexingConfigurationCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/indexing/config");
    let body;
    body = "";
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_GetJobDocumentCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/jobs/{jobId}/job-document");
    b.p("jobId", () => input.jobId, "{jobId}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_GetLoggingOptionsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/loggingOptions");
    let body;
    body = "";
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_GetOTAUpdateCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/otaUpdates/{otaUpdateId}");
    b.p("otaUpdateId", () => input.otaUpdateId, "{otaUpdateId}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_GetPackageCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/packages/{packageName}");
    b.p("packageName", () => input.packageName, "{packageName}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_GetPackageConfigurationCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/package-configuration");
    let body;
    body = "";
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_GetPackageVersionCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/packages/{packageName}/versions/{versionName}");
    b.p("packageName", () => input.packageName, "{packageName}", false);
    b.p("versionName", () => input.versionName, "{versionName}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_GetPercentilesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/indices/percentiles");
    let body;
    body = JSON.stringify(take(input, {
        aggregationField: [],
        indexName: [],
        percents: (_) => se_PercentList(_, context),
        queryString: [],
        queryVersion: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_GetPolicyCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/policies/{policyName}");
    b.p("policyName", () => input.policyName, "{policyName}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_GetPolicyVersionCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/policies/{policyName}/version/{policyVersionId}");
    b.p("policyName", () => input.policyName, "{policyName}", false);
    b.p("policyVersionId", () => input.policyVersionId, "{policyVersionId}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_GetRegistrationCodeCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/registrationcode");
    let body;
    body = "";
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_GetStatisticsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/indices/statistics");
    let body;
    body = JSON.stringify(take(input, {
        aggregationField: [],
        indexName: [],
        queryString: [],
        queryVersion: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_GetTopicRuleCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/rules/{ruleName}");
    b.p("ruleName", () => input.ruleName, "{ruleName}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_GetTopicRuleDestinationCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/destinations/{arn+}");
    b.p("arn", () => input.arn, "{arn+}", true);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_GetV2LoggingOptionsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/v2LoggingOptions");
    let body;
    body = "";
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_ListActiveViolationsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/active-violations");
    const query = map({
        [_tNh]: [, input[_tNh]],
        [_sPN]: [, input[_sPN]],
        [_bCT]: [, input[_bCT]],
        [_lSA]: [() => input.listSuppressedAlerts !== void 0, () => input[_lSA].toString()],
        [_vS]: [, input[_vS]],
        [_nT]: [, input[_nT]],
        [_mR]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListAttachedPoliciesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/attached-policies/{target}");
    b.p("target", () => input.target, "{target}", false);
    const query = map({
        [_r]: [() => input.recursive !== void 0, () => input[_r].toString()],
        [_m]: [, input[_m]],
        [_pS]: [() => input.pageSize !== void 0, () => input[_pS].toString()],
    });
    let body;
    b.m("POST").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListAuditFindingsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/audit/findings");
    let body;
    body = JSON.stringify(take(input, {
        checkName: [],
        endTime: (_) => Math.round(_.getTime() / 1000),
        listSuppressedFindings: [],
        maxResults: [],
        nextToken: [],
        resourceIdentifier: (_) => _json(_),
        startTime: (_) => Math.round(_.getTime() / 1000),
        taskId: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_ListAuditMitigationActionsExecutionsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/audit/mitigationactions/executions");
    const query = map({
        [_tI]: [, __expectNonNull(input[_tI], `taskId`)],
        [_aS]: [, input[_aS]],
        [_fI]: [, __expectNonNull(input[_fI], `findingId`)],
        [_mR]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
        [_nT]: [, input[_nT]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListAuditMitigationActionsTasksCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/audit/mitigationactions/tasks");
    const query = map({
        [_aTI]: [, input[_aTI]],
        [_fI]: [, input[_fI]],
        [_tS]: [, input[_tS]],
        [_mR]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
        [_nT]: [, input[_nT]],
        [_sT]: [
            __expectNonNull(input.startTime, `startTime`) != null,
            () => (input[_sT].toISOString().split(".")[0] + "Z").toString(),
        ],
        [_eTn]: [
            __expectNonNull(input.endTime, `endTime`) != null,
            () => (input[_eTn].toISOString().split(".")[0] + "Z").toString(),
        ],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListAuditSuppressionsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/audit/suppressions/list");
    let body;
    body = JSON.stringify(take(input, {
        ascendingOrder: [],
        checkName: [],
        maxResults: [],
        nextToken: [],
        resourceIdentifier: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_ListAuditTasksCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/audit/tasks");
    const query = map({
        [_sT]: [
            __expectNonNull(input.startTime, `startTime`) != null,
            () => (input[_sT].toISOString().split(".")[0] + "Z").toString(),
        ],
        [_eTn]: [
            __expectNonNull(input.endTime, `endTime`) != null,
            () => (input[_eTn].toISOString().split(".")[0] + "Z").toString(),
        ],
        [_tTa]: [, input[_tTa]],
        [_tS]: [, input[_tS]],
        [_nT]: [, input[_nT]],
        [_mR]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListAuthorizersCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/authorizers");
    const query = map({
        [_pS]: [() => input.pageSize !== void 0, () => input[_pS].toString()],
        [_m]: [, input[_m]],
        [_iAO]: [() => input.ascendingOrder !== void 0, () => input[_aO].toString()],
        [_s]: [, input[_s]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListBillingGroupsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/billing-groups");
    const query = map({
        [_nT]: [, input[_nT]],
        [_mR]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
        [_nPF]: [, input[_nPF]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListCACertificatesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/cacertificates");
    const query = map({
        [_pS]: [() => input.pageSize !== void 0, () => input[_pS].toString()],
        [_m]: [, input[_m]],
        [_iAO]: [() => input.ascendingOrder !== void 0, () => input[_aO].toString()],
        [_tNe]: [, input[_tNe]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListCertificateProvidersCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/certificate-providers");
    const query = map({
        [_nT]: [, input[_nT]],
        [_iAO]: [() => input.ascendingOrder !== void 0, () => input[_aO].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListCertificatesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/certificates");
    const query = map({
        [_pS]: [() => input.pageSize !== void 0, () => input[_pS].toString()],
        [_m]: [, input[_m]],
        [_iAO]: [() => input.ascendingOrder !== void 0, () => input[_aO].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListCertificatesByCACommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/certificates-by-ca/{caCertificateId}");
    b.p("caCertificateId", () => input.caCertificateId, "{caCertificateId}", false);
    const query = map({
        [_pS]: [() => input.pageSize !== void 0, () => input[_pS].toString()],
        [_m]: [, input[_m]],
        [_iAO]: [() => input.ascendingOrder !== void 0, () => input[_aO].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListCustomMetricsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/custom-metrics");
    const query = map({
        [_nT]: [, input[_nT]],
        [_mR]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListDetectMitigationActionsExecutionsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/detect/mitigationactions/executions");
    const query = map({
        [_tI]: [, input[_tI]],
        [_vI]: [, input[_vI]],
        [_tNh]: [, input[_tNh]],
        [_sT]: [() => input.startTime !== void 0, () => (input[_sT].toISOString().split(".")[0] + "Z").toString()],
        [_eTn]: [() => input.endTime !== void 0, () => (input[_eTn].toISOString().split(".")[0] + "Z").toString()],
        [_mR]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
        [_nT]: [, input[_nT]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListDetectMitigationActionsTasksCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/detect/mitigationactions/tasks");
    const query = map({
        [_mR]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
        [_nT]: [, input[_nT]],
        [_sT]: [
            __expectNonNull(input.startTime, `startTime`) != null,
            () => (input[_sT].toISOString().split(".")[0] + "Z").toString(),
        ],
        [_eTn]: [
            __expectNonNull(input.endTime, `endTime`) != null,
            () => (input[_eTn].toISOString().split(".")[0] + "Z").toString(),
        ],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListDimensionsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/dimensions");
    const query = map({
        [_nT]: [, input[_nT]],
        [_mR]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListDomainConfigurationsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/domainConfigurations");
    const query = map({
        [_m]: [, input[_m]],
        [_pS]: [() => input.pageSize !== void 0, () => input[_pS].toString()],
        [_sTe]: [, input[_sTe]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListFleetMetricsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/fleet-metrics");
    const query = map({
        [_nT]: [, input[_nT]],
        [_mR]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListIndicesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/indices");
    const query = map({
        [_nT]: [, input[_nT]],
        [_mR]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListJobExecutionsForJobCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/jobs/{jobId}/things");
    b.p("jobId", () => input.jobId, "{jobId}", false);
    const query = map({
        [_s]: [, input[_s]],
        [_mR]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
        [_nT]: [, input[_nT]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListJobExecutionsForThingCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/things/{thingName}/jobs");
    b.p("thingName", () => input.thingName, "{thingName}", false);
    const query = map({
        [_s]: [, input[_s]],
        [_nI]: [, input[_nI]],
        [_mR]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
        [_nT]: [, input[_nT]],
        [_jI]: [, input[_jI]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListJobsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/jobs");
    const query = map({
        [_s]: [, input[_s]],
        [_tSa]: [, input[_tSa]],
        [_mR]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
        [_nT]: [, input[_nT]],
        [_tGN]: [, input[_tGN]],
        [_tGI]: [, input[_tGI]],
        [_nI]: [, input[_nI]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListJobTemplatesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/job-templates");
    const query = map({
        [_mR]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
        [_nT]: [, input[_nT]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListManagedJobTemplatesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/managed-job-templates");
    const query = map({
        [_tNe]: [, input[_tNe]],
        [_mR]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
        [_nT]: [, input[_nT]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListMetricValuesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/metric-values");
    const query = map({
        [_tNh]: [, __expectNonNull(input[_tNh], `thingName`)],
        [_mN]: [, __expectNonNull(input[_mN], `metricName`)],
        [_dN]: [, input[_dN]],
        [_dVO]: [, input[_dVO]],
        [_sT]: [
            __expectNonNull(input.startTime, `startTime`) != null,
            () => (input[_sT].toISOString().split(".")[0] + "Z").toString(),
        ],
        [_eTn]: [
            __expectNonNull(input.endTime, `endTime`) != null,
            () => (input[_eTn].toISOString().split(".")[0] + "Z").toString(),
        ],
        [_mR]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
        [_nT]: [, input[_nT]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListMitigationActionsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/mitigationactions/actions");
    const query = map({
        [_aT]: [, input[_aT]],
        [_mR]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
        [_nT]: [, input[_nT]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListOTAUpdatesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/otaUpdates");
    const query = map({
        [_mR]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
        [_nT]: [, input[_nT]],
        [_oUS]: [, input[_oUS]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListOutgoingCertificatesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/certificates-out-going");
    const query = map({
        [_pS]: [() => input.pageSize !== void 0, () => input[_pS].toString()],
        [_m]: [, input[_m]],
        [_iAO]: [() => input.ascendingOrder !== void 0, () => input[_aO].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListPackagesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/packages");
    const query = map({
        [_mR]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
        [_nT]: [, input[_nT]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListPackageVersionsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/packages/{packageName}/versions");
    b.p("packageName", () => input.packageName, "{packageName}", false);
    const query = map({
        [_s]: [, input[_s]],
        [_mR]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
        [_nT]: [, input[_nT]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListPoliciesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/policies");
    const query = map({
        [_m]: [, input[_m]],
        [_pS]: [() => input.pageSize !== void 0, () => input[_pS].toString()],
        [_iAO]: [() => input.ascendingOrder !== void 0, () => input[_aO].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListPolicyPrincipalsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        [_xaip_]: input[_pN],
    });
    b.bp("/policy-principals");
    const query = map({
        [_m]: [, input[_m]],
        [_pS]: [() => input.pageSize !== void 0, () => input[_pS].toString()],
        [_iAO]: [() => input.ascendingOrder !== void 0, () => input[_aO].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListPolicyVersionsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/policies/{policyName}/version");
    b.p("policyName", () => input.policyName, "{policyName}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_ListPrincipalPoliciesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        [_xaip]: input[_p],
    });
    b.bp("/principal-policies");
    const query = map({
        [_m]: [, input[_m]],
        [_pS]: [() => input.pageSize !== void 0, () => input[_pS].toString()],
        [_iAO]: [() => input.ascendingOrder !== void 0, () => input[_aO].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListPrincipalThingsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        [_xap]: input[_p],
    });
    b.bp("/principals/things");
    const query = map({
        [_nT]: [, input[_nT]],
        [_mR]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListProvisioningTemplatesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/provisioning-templates");
    const query = map({
        [_mR]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
        [_nT]: [, input[_nT]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListProvisioningTemplateVersionsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/provisioning-templates/{templateName}/versions");
    b.p("templateName", () => input.templateName, "{templateName}", false);
    const query = map({
        [_mR]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
        [_nT]: [, input[_nT]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListRelatedResourcesForAuditFindingCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/audit/relatedResources");
    const query = map({
        [_fI]: [, __expectNonNull(input[_fI], `findingId`)],
        [_nT]: [, input[_nT]],
        [_mR]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListRoleAliasesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/role-aliases");
    const query = map({
        [_pS]: [() => input.pageSize !== void 0, () => input[_pS].toString()],
        [_m]: [, input[_m]],
        [_iAO]: [() => input.ascendingOrder !== void 0, () => input[_aO].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListScheduledAuditsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/audit/scheduledaudits");
    const query = map({
        [_nT]: [, input[_nT]],
        [_mR]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListSecurityProfilesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/security-profiles");
    const query = map({
        [_nT]: [, input[_nT]],
        [_mR]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
        [_dN]: [, input[_dN]],
        [_mN]: [, input[_mN]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListSecurityProfilesForTargetCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/security-profiles-for-target");
    const query = map({
        [_nT]: [, input[_nT]],
        [_mR]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
        [_r]: [() => input.recursive !== void 0, () => input[_r].toString()],
        [_sPTA]: [, __expectNonNull(input[_sPTA], `securityProfileTargetArn`)],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListStreamsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/streams");
    const query = map({
        [_mR]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
        [_nT]: [, input[_nT]],
        [_iAO]: [() => input.ascendingOrder !== void 0, () => input[_aO].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListTagsForResourceCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/tags");
    const query = map({
        [_rA]: [, __expectNonNull(input[_rA], `resourceArn`)],
        [_nT]: [, input[_nT]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListTargetsForPolicyCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/policy-targets/{policyName}");
    b.p("policyName", () => input.policyName, "{policyName}", false);
    const query = map({
        [_m]: [, input[_m]],
        [_pS]: [() => input.pageSize !== void 0, () => input[_pS].toString()],
    });
    let body;
    b.m("POST").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListTargetsForSecurityProfileCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/security-profiles/{securityProfileName}/targets");
    b.p("securityProfileName", () => input.securityProfileName, "{securityProfileName}", false);
    const query = map({
        [_nT]: [, input[_nT]],
        [_mR]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListThingGroupsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/thing-groups");
    const query = map({
        [_nT]: [, input[_nT]],
        [_mR]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
        [_pG]: [, input[_pG]],
        [_nPF]: [, input[_nPF]],
        [_r]: [() => input.recursive !== void 0, () => input[_r].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListThingGroupsForThingCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/things/{thingName}/thing-groups");
    b.p("thingName", () => input.thingName, "{thingName}", false);
    const query = map({
        [_nT]: [, input[_nT]],
        [_mR]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListThingPrincipalsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/things/{thingName}/principals");
    b.p("thingName", () => input.thingName, "{thingName}", false);
    const query = map({
        [_nT]: [, input[_nT]],
        [_mR]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListThingRegistrationTaskReportsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/thing-registration-tasks/{taskId}/reports");
    b.p("taskId", () => input.taskId, "{taskId}", false);
    const query = map({
        [_rT]: [, __expectNonNull(input[_rT], `reportType`)],
        [_nT]: [, input[_nT]],
        [_mR]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListThingRegistrationTasksCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/thing-registration-tasks");
    const query = map({
        [_nT]: [, input[_nT]],
        [_mR]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
        [_s]: [, input[_s]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListThingsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/things");
    const query = map({
        [_nT]: [, input[_nT]],
        [_mR]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
        [_aN]: [, input[_aN]],
        [_aV]: [, input[_aV]],
        [_tTN]: [, input[_tTN]],
        [_uPAV]: [() => input.usePrefixAttributeValue !== void 0, () => input[_uPAV].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListThingsInBillingGroupCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/billing-groups/{billingGroupName}/things");
    b.p("billingGroupName", () => input.billingGroupName, "{billingGroupName}", false);
    const query = map({
        [_nT]: [, input[_nT]],
        [_mR]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListThingsInThingGroupCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/thing-groups/{thingGroupName}/things");
    b.p("thingGroupName", () => input.thingGroupName, "{thingGroupName}", false);
    const query = map({
        [_r]: [() => input.recursive !== void 0, () => input[_r].toString()],
        [_nT]: [, input[_nT]],
        [_mR]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListThingTypesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/thing-types");
    const query = map({
        [_nT]: [, input[_nT]],
        [_mR]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
        [_tTN]: [, input[_tTN]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListTopicRuleDestinationsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/destinations");
    const query = map({
        [_mR]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
        [_nT]: [, input[_nT]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListTopicRulesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/rules");
    const query = map({
        [_to]: [, input[_to]],
        [_mR]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
        [_nT]: [, input[_nT]],
        [_rD]: [() => input.ruleDisabled !== void 0, () => input[_rD].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListV2LoggingLevelsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/v2LoggingLevel");
    const query = map({
        [_tT]: [, input[_tT]],
        [_nT]: [, input[_nT]],
        [_mR]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListViolationEventsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/violation-events");
    const query = map({
        [_sT]: [
            __expectNonNull(input.startTime, `startTime`) != null,
            () => (input[_sT].toISOString().split(".")[0] + "Z").toString(),
        ],
        [_eTn]: [
            __expectNonNull(input.endTime, `endTime`) != null,
            () => (input[_eTn].toISOString().split(".")[0] + "Z").toString(),
        ],
        [_tNh]: [, input[_tNh]],
        [_sPN]: [, input[_sPN]],
        [_bCT]: [, input[_bCT]],
        [_lSA]: [() => input.listSuppressedAlerts !== void 0, () => input[_lSA].toString()],
        [_vS]: [, input[_vS]],
        [_nT]: [, input[_nT]],
        [_mR]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_PutVerificationStateOnViolationCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/violations/verification-state/{violationId}");
    b.p("violationId", () => input.violationId, "{violationId}", false);
    let body;
    body = JSON.stringify(take(input, {
        verificationState: [],
        verificationStateDescription: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_RegisterCACertificateCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/cacertificate");
    const query = map({
        [_sAA]: [() => input.setAsActive !== void 0, () => input[_sAA].toString()],
        [_aAR]: [() => input.allowAutoRegistration !== void 0, () => input[_aAR].toString()],
    });
    let body;
    body = JSON.stringify(take(input, {
        caCertificate: [],
        certificateMode: [],
        registrationConfig: (_) => _json(_),
        tags: (_) => _json(_),
        verificationCertificate: [],
    }));
    b.m("POST").h(headers).q(query).b(body);
    return b.build();
};
export const se_RegisterCertificateCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/certificate/register");
    const query = map({
        [_sAA]: [() => input.setAsActive !== void 0, () => input[_sAA].toString()],
    });
    let body;
    body = JSON.stringify(take(input, {
        caCertificatePem: [],
        certificatePem: [],
        status: [],
    }));
    b.m("POST").h(headers).q(query).b(body);
    return b.build();
};
export const se_RegisterCertificateWithoutCACommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/certificate/register-no-ca");
    let body;
    body = JSON.stringify(take(input, {
        certificatePem: [],
        status: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_RegisterThingCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/things");
    let body;
    body = JSON.stringify(take(input, {
        parameters: (_) => _json(_),
        templateBody: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_RejectCertificateTransferCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/reject-certificate-transfer/{certificateId}");
    b.p("certificateId", () => input.certificateId, "{certificateId}", false);
    let body;
    body = JSON.stringify(take(input, {
        rejectReason: [],
    }));
    b.m("PATCH").h(headers).b(body);
    return b.build();
};
export const se_RemoveThingFromBillingGroupCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/billing-groups/removeThingFromBillingGroup");
    let body;
    body = JSON.stringify(take(input, {
        billingGroupArn: [],
        billingGroupName: [],
        thingArn: [],
        thingName: [],
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_RemoveThingFromThingGroupCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/thing-groups/removeThingFromThingGroup");
    let body;
    body = JSON.stringify(take(input, {
        thingArn: [],
        thingGroupArn: [],
        thingGroupName: [],
        thingName: [],
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_ReplaceTopicRuleCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/rules/{ruleName}");
    b.p("ruleName", () => input.ruleName, "{ruleName}", false);
    let body;
    if (input.topicRulePayload !== undefined) {
        body = _json(input.topicRulePayload);
    }
    if (body === undefined) {
        body = {};
    }
    body = JSON.stringify(body);
    b.m("PATCH").h(headers).b(body);
    return b.build();
};
export const se_SearchIndexCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/indices/search");
    let body;
    body = JSON.stringify(take(input, {
        indexName: [],
        maxResults: [],
        nextToken: [],
        queryString: [],
        queryVersion: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_SetDefaultAuthorizerCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/default-authorizer");
    let body;
    body = JSON.stringify(take(input, {
        authorizerName: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_SetDefaultPolicyVersionCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/policies/{policyName}/version/{policyVersionId}");
    b.p("policyName", () => input.policyName, "{policyName}", false);
    b.p("policyVersionId", () => input.policyVersionId, "{policyVersionId}", false);
    let body;
    b.m("PATCH").h(headers).b(body);
    return b.build();
};
export const se_SetLoggingOptionsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/loggingOptions");
    let body;
    if (input.loggingOptionsPayload !== undefined) {
        body = _json(input.loggingOptionsPayload);
    }
    if (body === undefined) {
        body = {};
    }
    body = JSON.stringify(body);
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_SetV2LoggingLevelCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/v2LoggingLevel");
    let body;
    body = JSON.stringify(take(input, {
        logLevel: [],
        logTarget: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_SetV2LoggingOptionsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/v2LoggingOptions");
    let body;
    body = JSON.stringify(take(input, {
        defaultLogLevel: [],
        disableAllLogs: [],
        roleArn: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_StartAuditMitigationActionsTaskCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/audit/mitigationactions/tasks/{taskId}");
    b.p("taskId", () => input.taskId, "{taskId}", false);
    let body;
    body = JSON.stringify(take(input, {
        auditCheckToActionsMapping: (_) => _json(_),
        clientRequestToken: [true, (_) => _ ?? generateIdempotencyToken()],
        target: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_StartDetectMitigationActionsTaskCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/detect/mitigationactions/tasks/{taskId}");
    b.p("taskId", () => input.taskId, "{taskId}", false);
    let body;
    body = JSON.stringify(take(input, {
        actions: (_) => _json(_),
        clientRequestToken: [true, (_) => _ ?? generateIdempotencyToken()],
        includeOnlyActiveViolations: [],
        includeSuppressedAlerts: [],
        target: (_) => _json(_),
        violationEventOccurrenceRange: (_) => se_ViolationEventOccurrenceRange(_, context),
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_StartOnDemandAuditTaskCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/audit/tasks");
    let body;
    body = JSON.stringify(take(input, {
        targetCheckNames: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_StartThingRegistrationTaskCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/thing-registration-tasks");
    let body;
    body = JSON.stringify(take(input, {
        inputFileBucket: [],
        inputFileKey: [],
        roleArn: [],
        templateBody: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_StopThingRegistrationTaskCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/thing-registration-tasks/{taskId}/cancel");
    b.p("taskId", () => input.taskId, "{taskId}", false);
    let body;
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_TagResourceCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/tags");
    let body;
    body = JSON.stringify(take(input, {
        resourceArn: [],
        tags: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_TestAuthorizationCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/test-authorization");
    const query = map({
        [_cI]: [, input[_cI]],
    });
    let body;
    body = JSON.stringify(take(input, {
        authInfos: (_) => _json(_),
        cognitoIdentityPoolId: [],
        policyNamesToAdd: (_) => _json(_),
        policyNamesToSkip: (_) => _json(_),
        principal: [],
    }));
    b.m("POST").h(headers).q(query).b(body);
    return b.build();
};
export const se_TestInvokeAuthorizerCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/authorizer/{authorizerName}/test");
    b.p("authorizerName", () => input.authorizerName, "{authorizerName}", false);
    let body;
    body = JSON.stringify(take(input, {
        httpContext: (_) => _json(_),
        mqttContext: (_) => se_MqttContext(_, context),
        tlsContext: (_) => _json(_),
        token: [],
        tokenSignature: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_TransferCertificateCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/transfer-certificate/{certificateId}");
    b.p("certificateId", () => input.certificateId, "{certificateId}", false);
    const query = map({
        [_tAA]: [, __expectNonNull(input[_tAA], `targetAwsAccount`)],
    });
    let body;
    body = JSON.stringify(take(input, {
        transferMessage: [],
    }));
    b.m("PATCH").h(headers).q(query).b(body);
    return b.build();
};
export const se_UntagResourceCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/untag");
    let body;
    body = JSON.stringify(take(input, {
        resourceArn: [],
        tagKeys: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_UpdateAccountAuditConfigurationCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/audit/configuration");
    let body;
    body = JSON.stringify(take(input, {
        auditCheckConfigurations: (_) => _json(_),
        auditNotificationTargetConfigurations: (_) => _json(_),
        roleArn: [],
    }));
    b.m("PATCH").h(headers).b(body);
    return b.build();
};
export const se_UpdateAuditSuppressionCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/audit/suppressions/update");
    let body;
    body = JSON.stringify(take(input, {
        checkName: [],
        description: [],
        expirationDate: (_) => Math.round(_.getTime() / 1000),
        resourceIdentifier: (_) => _json(_),
        suppressIndefinitely: [],
    }));
    b.m("PATCH").h(headers).b(body);
    return b.build();
};
export const se_UpdateAuthorizerCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/authorizer/{authorizerName}");
    b.p("authorizerName", () => input.authorizerName, "{authorizerName}", false);
    let body;
    body = JSON.stringify(take(input, {
        authorizerFunctionArn: [],
        enableCachingForHttp: [],
        status: [],
        tokenKeyName: [],
        tokenSigningPublicKeys: (_) => _json(_),
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_UpdateBillingGroupCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/billing-groups/{billingGroupName}");
    b.p("billingGroupName", () => input.billingGroupName, "{billingGroupName}", false);
    let body;
    body = JSON.stringify(take(input, {
        billingGroupProperties: (_) => _json(_),
        expectedVersion: [],
    }));
    b.m("PATCH").h(headers).b(body);
    return b.build();
};
export const se_UpdateCACertificateCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/cacertificate/{certificateId}");
    b.p("certificateId", () => input.certificateId, "{certificateId}", false);
    const query = map({
        [_nS]: [, input[_nS]],
        [_nARS]: [, input[_nARS]],
    });
    let body;
    body = JSON.stringify(take(input, {
        registrationConfig: (_) => _json(_),
        removeAutoRegistration: [],
    }));
    b.m("PUT").h(headers).q(query).b(body);
    return b.build();
};
export const se_UpdateCertificateCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/certificates/{certificateId}");
    b.p("certificateId", () => input.certificateId, "{certificateId}", false);
    const query = map({
        [_nS]: [, __expectNonNull(input[_nS], `newStatus`)],
    });
    let body;
    b.m("PUT").h(headers).q(query).b(body);
    return b.build();
};
export const se_UpdateCertificateProviderCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/certificate-providers/{certificateProviderName}");
    b.p("certificateProviderName", () => input.certificateProviderName, "{certificateProviderName}", false);
    let body;
    body = JSON.stringify(take(input, {
        accountDefaultForOperations: (_) => _json(_),
        lambdaFunctionArn: [],
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_UpdateCustomMetricCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/custom-metric/{metricName}");
    b.p("metricName", () => input.metricName, "{metricName}", false);
    let body;
    body = JSON.stringify(take(input, {
        displayName: [],
    }));
    b.m("PATCH").h(headers).b(body);
    return b.build();
};
export const se_UpdateDimensionCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/dimensions/{name}");
    b.p("name", () => input.name, "{name}", false);
    let body;
    body = JSON.stringify(take(input, {
        stringValues: (_) => _json(_),
    }));
    b.m("PATCH").h(headers).b(body);
    return b.build();
};
export const se_UpdateDomainConfigurationCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/domainConfigurations/{domainConfigurationName}");
    b.p("domainConfigurationName", () => input.domainConfigurationName, "{domainConfigurationName}", false);
    let body;
    body = JSON.stringify(take(input, {
        authorizerConfig: (_) => _json(_),
        domainConfigurationStatus: [],
        removeAuthorizerConfig: [],
        tlsConfig: (_) => _json(_),
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_UpdateDynamicThingGroupCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/dynamic-thing-groups/{thingGroupName}");
    b.p("thingGroupName", () => input.thingGroupName, "{thingGroupName}", false);
    let body;
    body = JSON.stringify(take(input, {
        expectedVersion: [],
        indexName: [],
        queryString: [],
        queryVersion: [],
        thingGroupProperties: (_) => _json(_),
    }));
    b.m("PATCH").h(headers).b(body);
    return b.build();
};
export const se_UpdateEventConfigurationsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/event-configurations");
    let body;
    body = JSON.stringify(take(input, {
        eventConfigurations: (_) => _json(_),
    }));
    b.m("PATCH").h(headers).b(body);
    return b.build();
};
export const se_UpdateFleetMetricCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/fleet-metric/{metricName}");
    b.p("metricName", () => input.metricName, "{metricName}", false);
    let body;
    body = JSON.stringify(take(input, {
        aggregationField: [],
        aggregationType: (_) => _json(_),
        description: [],
        expectedVersion: [],
        indexName: [],
        period: [],
        queryString: [],
        queryVersion: [],
        unit: [],
    }));
    b.m("PATCH").h(headers).b(body);
    return b.build();
};
export const se_UpdateIndexingConfigurationCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/indexing/config");
    let body;
    body = JSON.stringify(take(input, {
        thingGroupIndexingConfiguration: (_) => _json(_),
        thingIndexingConfiguration: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_UpdateJobCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/jobs/{jobId}");
    b.p("jobId", () => input.jobId, "{jobId}", false);
    const query = map({
        [_nI]: [, input[_nI]],
    });
    let body;
    body = JSON.stringify(take(input, {
        abortConfig: (_) => se_AbortConfig(_, context),
        description: [],
        jobExecutionsRetryConfig: (_) => _json(_),
        jobExecutionsRolloutConfig: (_) => se_JobExecutionsRolloutConfig(_, context),
        presignedUrlConfig: (_) => _json(_),
        timeoutConfig: (_) => _json(_),
    }));
    b.m("PATCH").h(headers).q(query).b(body);
    return b.build();
};
export const se_UpdateMitigationActionCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/mitigationactions/actions/{actionName}");
    b.p("actionName", () => input.actionName, "{actionName}", false);
    let body;
    body = JSON.stringify(take(input, {
        actionParams: (_) => _json(_),
        roleArn: [],
    }));
    b.m("PATCH").h(headers).b(body);
    return b.build();
};
export const se_UpdatePackageCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/packages/{packageName}");
    b.p("packageName", () => input.packageName, "{packageName}", false);
    const query = map({
        [_cT]: [, input[_cT] ?? generateIdempotencyToken()],
    });
    let body;
    body = JSON.stringify(take(input, {
        defaultVersionName: [],
        description: [],
        unsetDefaultVersion: [],
    }));
    b.m("PATCH").h(headers).q(query).b(body);
    return b.build();
};
export const se_UpdatePackageConfigurationCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/package-configuration");
    const query = map({
        [_cT]: [, input[_cT] ?? generateIdempotencyToken()],
    });
    let body;
    body = JSON.stringify(take(input, {
        versionUpdateByJobsConfig: (_) => _json(_),
    }));
    b.m("PATCH").h(headers).q(query).b(body);
    return b.build();
};
export const se_UpdatePackageVersionCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/packages/{packageName}/versions/{versionName}");
    b.p("packageName", () => input.packageName, "{packageName}", false);
    b.p("versionName", () => input.versionName, "{versionName}", false);
    const query = map({
        [_cT]: [, input[_cT] ?? generateIdempotencyToken()],
    });
    let body;
    body = JSON.stringify(take(input, {
        action: [],
        attributes: (_) => _json(_),
        description: [],
    }));
    b.m("PATCH").h(headers).q(query).b(body);
    return b.build();
};
export const se_UpdateProvisioningTemplateCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/provisioning-templates/{templateName}");
    b.p("templateName", () => input.templateName, "{templateName}", false);
    let body;
    body = JSON.stringify(take(input, {
        defaultVersionId: [],
        description: [],
        enabled: [],
        preProvisioningHook: (_) => _json(_),
        provisioningRoleArn: [],
        removePreProvisioningHook: [],
    }));
    b.m("PATCH").h(headers).b(body);
    return b.build();
};
export const se_UpdateRoleAliasCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/role-aliases/{roleAlias}");
    b.p("roleAlias", () => input.roleAlias, "{roleAlias}", false);
    let body;
    body = JSON.stringify(take(input, {
        credentialDurationSeconds: [],
        roleArn: [],
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_UpdateScheduledAuditCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/audit/scheduledaudits/{scheduledAuditName}");
    b.p("scheduledAuditName", () => input.scheduledAuditName, "{scheduledAuditName}", false);
    let body;
    body = JSON.stringify(take(input, {
        dayOfMonth: [],
        dayOfWeek: [],
        frequency: [],
        targetCheckNames: (_) => _json(_),
    }));
    b.m("PATCH").h(headers).b(body);
    return b.build();
};
export const se_UpdateSecurityProfileCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/security-profiles/{securityProfileName}");
    b.p("securityProfileName", () => input.securityProfileName, "{securityProfileName}", false);
    const query = map({
        [_eV]: [() => input.expectedVersion !== void 0, () => input[_eV].toString()],
    });
    let body;
    body = JSON.stringify(take(input, {
        additionalMetricsToRetain: (_) => _json(_),
        additionalMetricsToRetainV2: (_) => _json(_),
        alertTargets: (_) => _json(_),
        behaviors: (_) => se_Behaviors(_, context),
        deleteAdditionalMetricsToRetain: [],
        deleteAlertTargets: [],
        deleteBehaviors: [],
        deleteMetricsExportConfig: [],
        metricsExportConfig: (_) => _json(_),
        securityProfileDescription: [],
    }));
    b.m("PATCH").h(headers).q(query).b(body);
    return b.build();
};
export const se_UpdateStreamCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/streams/{streamId}");
    b.p("streamId", () => input.streamId, "{streamId}", false);
    let body;
    body = JSON.stringify(take(input, {
        description: [],
        files: (_) => _json(_),
        roleArn: [],
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_UpdateThingCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/things/{thingName}");
    b.p("thingName", () => input.thingName, "{thingName}", false);
    let body;
    body = JSON.stringify(take(input, {
        attributePayload: (_) => _json(_),
        expectedVersion: [],
        removeThingType: [],
        thingTypeName: [],
    }));
    b.m("PATCH").h(headers).b(body);
    return b.build();
};
export const se_UpdateThingGroupCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/thing-groups/{thingGroupName}");
    b.p("thingGroupName", () => input.thingGroupName, "{thingGroupName}", false);
    let body;
    body = JSON.stringify(take(input, {
        expectedVersion: [],
        thingGroupProperties: (_) => _json(_),
    }));
    b.m("PATCH").h(headers).b(body);
    return b.build();
};
export const se_UpdateThingGroupsForThingCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/thing-groups/updateThingGroupsForThing");
    let body;
    body = JSON.stringify(take(input, {
        overrideDynamicGroups: [],
        thingGroupsToAdd: (_) => _json(_),
        thingGroupsToRemove: (_) => _json(_),
        thingName: [],
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_UpdateTopicRuleDestinationCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/destinations");
    let body;
    body = JSON.stringify(take(input, {
        arn: [],
        status: [],
    }));
    b.m("PATCH").h(headers).b(body);
    return b.build();
};
export const se_ValidateSecurityProfileBehaviorsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/security-profile-behaviors/validate");
    let body;
    body = JSON.stringify(take(input, {
        behaviors: (_) => se_Behaviors(_, context),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const de_AcceptCertificateTransferCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_AcceptCertificateTransferCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_AcceptCertificateTransferCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "TransferAlreadyCompletedException":
        case "com.amazonaws.iot#TransferAlreadyCompletedException":
            throw await de_TransferAlreadyCompletedExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_AddThingToBillingGroupCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_AddThingToBillingGroupCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_AddThingToBillingGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_AddThingToThingGroupCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_AddThingToThingGroupCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_AddThingToThingGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_AssociateTargetsWithJobCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_AssociateTargetsWithJobCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        description: __expectString,
        jobArn: __expectString,
        jobId: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_AssociateTargetsWithJobCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_AttachPolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_AttachPolicyCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_AttachPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_AttachPrincipalPolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_AttachPrincipalPolicyCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_AttachPrincipalPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_AttachSecurityProfileCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_AttachSecurityProfileCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_AttachSecurityProfileCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "VersionConflictException":
        case "com.amazonaws.iot#VersionConflictException":
            throw await de_VersionConflictExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_AttachThingPrincipalCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_AttachThingPrincipalCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_AttachThingPrincipalCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_CancelAuditMitigationActionsTaskCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CancelAuditMitigationActionsTaskCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_CancelAuditMitigationActionsTaskCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_CancelAuditTaskCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CancelAuditTaskCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_CancelAuditTaskCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_CancelCertificateTransferCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CancelCertificateTransferCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_CancelCertificateTransferCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "TransferAlreadyCompletedException":
        case "com.amazonaws.iot#TransferAlreadyCompletedException":
            throw await de_TransferAlreadyCompletedExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_CancelDetectMitigationActionsTaskCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CancelDetectMitigationActionsTaskCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_CancelDetectMitigationActionsTaskCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_CancelJobCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CancelJobCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        description: __expectString,
        jobArn: __expectString,
        jobId: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_CancelJobCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_CancelJobExecutionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CancelJobExecutionCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_CancelJobExecutionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "InvalidStateTransitionException":
        case "com.amazonaws.iot#InvalidStateTransitionException":
            throw await de_InvalidStateTransitionExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "VersionConflictException":
        case "com.amazonaws.iot#VersionConflictException":
            throw await de_VersionConflictExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_ClearDefaultAuthorizerCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ClearDefaultAuthorizerCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_ClearDefaultAuthorizerCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_ConfirmTopicRuleDestinationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ConfirmTopicRuleDestinationCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_ConfirmTopicRuleDestinationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConflictingResourceUpdateException":
        case "com.amazonaws.iot#ConflictingResourceUpdateException":
            throw await de_ConflictingResourceUpdateExceptionRes(parsedOutput, context);
        case "InternalException":
        case "com.amazonaws.iot#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_CreateAuditSuppressionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CreateAuditSuppressionCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_CreateAuditSuppressionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            throw await de_ResourceAlreadyExistsExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_CreateAuthorizerCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CreateAuthorizerCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        authorizerArn: __expectString,
        authorizerName: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_CreateAuthorizerCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            throw await de_ResourceAlreadyExistsExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_CreateBillingGroupCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CreateBillingGroupCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        billingGroupArn: __expectString,
        billingGroupId: __expectString,
        billingGroupName: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_CreateBillingGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            throw await de_ResourceAlreadyExistsExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_CreateCertificateFromCsrCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CreateCertificateFromCsrCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        certificateArn: __expectString,
        certificateId: __expectString,
        certificatePem: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_CreateCertificateFromCsrCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_CreateCertificateProviderCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CreateCertificateProviderCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        certificateProviderArn: __expectString,
        certificateProviderName: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_CreateCertificateProviderCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            throw await de_ResourceAlreadyExistsExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_CreateCustomMetricCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CreateCustomMetricCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        metricArn: __expectString,
        metricName: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_CreateCustomMetricCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            throw await de_ResourceAlreadyExistsExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_CreateDimensionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CreateDimensionCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        arn: __expectString,
        name: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_CreateDimensionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            throw await de_ResourceAlreadyExistsExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_CreateDomainConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CreateDomainConfigurationCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        domainConfigurationArn: __expectString,
        domainConfigurationName: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_CreateDomainConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "CertificateValidationException":
        case "com.amazonaws.iot#CertificateValidationException":
            throw await de_CertificateValidationExceptionRes(parsedOutput, context);
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            throw await de_ResourceAlreadyExistsExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_CreateDynamicThingGroupCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CreateDynamicThingGroupCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        indexName: __expectString,
        queryString: __expectString,
        queryVersion: __expectString,
        thingGroupArn: __expectString,
        thingGroupId: __expectString,
        thingGroupName: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_CreateDynamicThingGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidQueryException":
        case "com.amazonaws.iot#InvalidQueryException":
            throw await de_InvalidQueryExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            throw await de_ResourceAlreadyExistsExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_CreateFleetMetricCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CreateFleetMetricCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        metricArn: __expectString,
        metricName: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_CreateFleetMetricCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "IndexNotReadyException":
        case "com.amazonaws.iot#IndexNotReadyException":
            throw await de_IndexNotReadyExceptionRes(parsedOutput, context);
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidAggregationException":
        case "com.amazonaws.iot#InvalidAggregationException":
            throw await de_InvalidAggregationExceptionRes(parsedOutput, context);
        case "InvalidQueryException":
        case "com.amazonaws.iot#InvalidQueryException":
            throw await de_InvalidQueryExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            throw await de_ResourceAlreadyExistsExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_CreateJobCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CreateJobCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        description: __expectString,
        jobArn: __expectString,
        jobId: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_CreateJobCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            throw await de_ResourceAlreadyExistsExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_CreateJobTemplateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CreateJobTemplateCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        jobTemplateArn: __expectString,
        jobTemplateId: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_CreateJobTemplateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConflictException":
        case "com.amazonaws.iot#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_CreateKeysAndCertificateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CreateKeysAndCertificateCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        certificateArn: __expectString,
        certificateId: __expectString,
        certificatePem: __expectString,
        keyPair: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_CreateKeysAndCertificateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_CreateMitigationActionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CreateMitigationActionCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        actionArn: __expectString,
        actionId: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_CreateMitigationActionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            throw await de_ResourceAlreadyExistsExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_CreateOTAUpdateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CreateOTAUpdateCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        awsIotJobArn: __expectString,
        awsIotJobId: __expectString,
        otaUpdateArn: __expectString,
        otaUpdateId: __expectString,
        otaUpdateStatus: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_CreateOTAUpdateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            throw await de_ResourceAlreadyExistsExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_CreatePackageCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CreatePackageCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        description: __expectString,
        packageArn: __expectString,
        packageName: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_CreatePackageCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConflictException":
        case "com.amazonaws.iot#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "InternalServerException":
        case "com.amazonaws.iot#InternalServerException":
            throw await de_InternalServerExceptionRes(parsedOutput, context);
        case "ServiceQuotaExceededException":
        case "com.amazonaws.iot#ServiceQuotaExceededException":
            throw await de_ServiceQuotaExceededExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.iot#ValidationException":
            throw await de_ValidationExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_CreatePackageVersionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CreatePackageVersionCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        attributes: _json,
        description: __expectString,
        errorReason: __expectString,
        packageName: __expectString,
        packageVersionArn: __expectString,
        status: __expectString,
        versionName: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_CreatePackageVersionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConflictException":
        case "com.amazonaws.iot#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "InternalServerException":
        case "com.amazonaws.iot#InternalServerException":
            throw await de_InternalServerExceptionRes(parsedOutput, context);
        case "ServiceQuotaExceededException":
        case "com.amazonaws.iot#ServiceQuotaExceededException":
            throw await de_ServiceQuotaExceededExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.iot#ValidationException":
            throw await de_ValidationExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_CreatePolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CreatePolicyCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        policyArn: __expectString,
        policyDocument: __expectString,
        policyName: __expectString,
        policyVersionId: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_CreatePolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "MalformedPolicyException":
        case "com.amazonaws.iot#MalformedPolicyException":
            throw await de_MalformedPolicyExceptionRes(parsedOutput, context);
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            throw await de_ResourceAlreadyExistsExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_CreatePolicyVersionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CreatePolicyVersionCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        isDefaultVersion: __expectBoolean,
        policyArn: __expectString,
        policyDocument: __expectString,
        policyVersionId: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_CreatePolicyVersionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "MalformedPolicyException":
        case "com.amazonaws.iot#MalformedPolicyException":
            throw await de_MalformedPolicyExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        case "VersionsLimitExceededException":
        case "com.amazonaws.iot#VersionsLimitExceededException":
            throw await de_VersionsLimitExceededExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_CreateProvisioningClaimCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CreateProvisioningClaimCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        certificateId: __expectString,
        certificatePem: __expectString,
        expiration: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        keyPair: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_CreateProvisioningClaimCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_CreateProvisioningTemplateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CreateProvisioningTemplateCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        defaultVersionId: __expectInt32,
        templateArn: __expectString,
        templateName: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_CreateProvisioningTemplateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            throw await de_ResourceAlreadyExistsExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_CreateProvisioningTemplateVersionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CreateProvisioningTemplateVersionCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        isDefaultVersion: __expectBoolean,
        templateArn: __expectString,
        templateName: __expectString,
        versionId: __expectInt32,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_CreateProvisioningTemplateVersionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConflictingResourceUpdateException":
        case "com.amazonaws.iot#ConflictingResourceUpdateException":
            throw await de_ConflictingResourceUpdateExceptionRes(parsedOutput, context);
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        case "VersionsLimitExceededException":
        case "com.amazonaws.iot#VersionsLimitExceededException":
            throw await de_VersionsLimitExceededExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_CreateRoleAliasCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CreateRoleAliasCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        roleAlias: __expectString,
        roleAliasArn: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_CreateRoleAliasCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            throw await de_ResourceAlreadyExistsExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_CreateScheduledAuditCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CreateScheduledAuditCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        scheduledAuditArn: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_CreateScheduledAuditCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            throw await de_ResourceAlreadyExistsExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_CreateSecurityProfileCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CreateSecurityProfileCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        securityProfileArn: __expectString,
        securityProfileName: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_CreateSecurityProfileCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            throw await de_ResourceAlreadyExistsExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_CreateStreamCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CreateStreamCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        description: __expectString,
        streamArn: __expectString,
        streamId: __expectString,
        streamVersion: __expectInt32,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_CreateStreamCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            throw await de_ResourceAlreadyExistsExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_CreateThingCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CreateThingCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        thingArn: __expectString,
        thingId: __expectString,
        thingName: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_CreateThingCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            throw await de_ResourceAlreadyExistsExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_CreateThingGroupCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CreateThingGroupCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        thingGroupArn: __expectString,
        thingGroupId: __expectString,
        thingGroupName: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_CreateThingGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            throw await de_ResourceAlreadyExistsExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_CreateThingTypeCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CreateThingTypeCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        thingTypeArn: __expectString,
        thingTypeId: __expectString,
        thingTypeName: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_CreateThingTypeCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            throw await de_ResourceAlreadyExistsExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_CreateTopicRuleCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CreateTopicRuleCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_CreateTopicRuleCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConflictingResourceUpdateException":
        case "com.amazonaws.iot#ConflictingResourceUpdateException":
            throw await de_ConflictingResourceUpdateExceptionRes(parsedOutput, context);
        case "InternalException":
        case "com.amazonaws.iot#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            throw await de_ResourceAlreadyExistsExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "SqlParseException":
        case "com.amazonaws.iot#SqlParseException":
            throw await de_SqlParseExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_CreateTopicRuleDestinationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CreateTopicRuleDestinationCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        topicRuleDestination: (_) => de_TopicRuleDestination(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
const de_CreateTopicRuleDestinationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConflictingResourceUpdateException":
        case "com.amazonaws.iot#ConflictingResourceUpdateException":
            throw await de_ConflictingResourceUpdateExceptionRes(parsedOutput, context);
        case "InternalException":
        case "com.amazonaws.iot#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            throw await de_ResourceAlreadyExistsExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DeleteAccountAuditConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteAccountAuditConfigurationCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DeleteAccountAuditConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DeleteAuditSuppressionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteAuditSuppressionCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DeleteAuditSuppressionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DeleteAuthorizerCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteAuthorizerCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DeleteAuthorizerCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DeleteConflictException":
        case "com.amazonaws.iot#DeleteConflictException":
            throw await de_DeleteConflictExceptionRes(parsedOutput, context);
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DeleteBillingGroupCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteBillingGroupCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DeleteBillingGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "VersionConflictException":
        case "com.amazonaws.iot#VersionConflictException":
            throw await de_VersionConflictExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DeleteCACertificateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteCACertificateCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DeleteCACertificateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "CertificateStateException":
        case "com.amazonaws.iot#CertificateStateException":
            throw await de_CertificateStateExceptionRes(parsedOutput, context);
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DeleteCertificateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteCertificateCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DeleteCertificateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "CertificateStateException":
        case "com.amazonaws.iot#CertificateStateException":
            throw await de_CertificateStateExceptionRes(parsedOutput, context);
        case "DeleteConflictException":
        case "com.amazonaws.iot#DeleteConflictException":
            throw await de_DeleteConflictExceptionRes(parsedOutput, context);
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DeleteCertificateProviderCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteCertificateProviderCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DeleteCertificateProviderCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DeleteConflictException":
        case "com.amazonaws.iot#DeleteConflictException":
            throw await de_DeleteConflictExceptionRes(parsedOutput, context);
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DeleteCustomMetricCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteCustomMetricCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DeleteCustomMetricCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DeleteDimensionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteDimensionCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DeleteDimensionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DeleteDomainConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteDomainConfigurationCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DeleteDomainConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DeleteDynamicThingGroupCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteDynamicThingGroupCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DeleteDynamicThingGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "VersionConflictException":
        case "com.amazonaws.iot#VersionConflictException":
            throw await de_VersionConflictExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DeleteFleetMetricCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteFleetMetricCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DeleteFleetMetricCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        case "VersionConflictException":
        case "com.amazonaws.iot#VersionConflictException":
            throw await de_VersionConflictExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DeleteJobCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteJobCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DeleteJobCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "InvalidStateTransitionException":
        case "com.amazonaws.iot#InvalidStateTransitionException":
            throw await de_InvalidStateTransitionExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DeleteJobExecutionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteJobExecutionCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DeleteJobExecutionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "InvalidStateTransitionException":
        case "com.amazonaws.iot#InvalidStateTransitionException":
            throw await de_InvalidStateTransitionExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DeleteJobTemplateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteJobTemplateCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DeleteJobTemplateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DeleteMitigationActionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteMitigationActionCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DeleteMitigationActionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DeleteOTAUpdateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteOTAUpdateCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DeleteOTAUpdateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        case "VersionConflictException":
        case "com.amazonaws.iot#VersionConflictException":
            throw await de_VersionConflictExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DeletePackageCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeletePackageCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DeletePackageCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerException":
        case "com.amazonaws.iot#InternalServerException":
            throw await de_InternalServerExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.iot#ValidationException":
            throw await de_ValidationExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DeletePackageVersionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeletePackageVersionCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DeletePackageVersionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerException":
        case "com.amazonaws.iot#InternalServerException":
            throw await de_InternalServerExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.iot#ValidationException":
            throw await de_ValidationExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DeletePolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeletePolicyCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DeletePolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DeleteConflictException":
        case "com.amazonaws.iot#DeleteConflictException":
            throw await de_DeleteConflictExceptionRes(parsedOutput, context);
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DeletePolicyVersionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeletePolicyVersionCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DeletePolicyVersionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DeleteConflictException":
        case "com.amazonaws.iot#DeleteConflictException":
            throw await de_DeleteConflictExceptionRes(parsedOutput, context);
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DeleteProvisioningTemplateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteProvisioningTemplateCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DeleteProvisioningTemplateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConflictingResourceUpdateException":
        case "com.amazonaws.iot#ConflictingResourceUpdateException":
            throw await de_ConflictingResourceUpdateExceptionRes(parsedOutput, context);
        case "DeleteConflictException":
        case "com.amazonaws.iot#DeleteConflictException":
            throw await de_DeleteConflictExceptionRes(parsedOutput, context);
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DeleteProvisioningTemplateVersionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteProvisioningTemplateVersionCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DeleteProvisioningTemplateVersionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConflictingResourceUpdateException":
        case "com.amazonaws.iot#ConflictingResourceUpdateException":
            throw await de_ConflictingResourceUpdateExceptionRes(parsedOutput, context);
        case "DeleteConflictException":
        case "com.amazonaws.iot#DeleteConflictException":
            throw await de_DeleteConflictExceptionRes(parsedOutput, context);
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DeleteRegistrationCodeCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteRegistrationCodeCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DeleteRegistrationCodeCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DeleteRoleAliasCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteRoleAliasCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DeleteRoleAliasCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DeleteConflictException":
        case "com.amazonaws.iot#DeleteConflictException":
            throw await de_DeleteConflictExceptionRes(parsedOutput, context);
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DeleteScheduledAuditCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteScheduledAuditCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DeleteScheduledAuditCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DeleteSecurityProfileCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteSecurityProfileCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DeleteSecurityProfileCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "VersionConflictException":
        case "com.amazonaws.iot#VersionConflictException":
            throw await de_VersionConflictExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DeleteStreamCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteStreamCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DeleteStreamCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DeleteConflictException":
        case "com.amazonaws.iot#DeleteConflictException":
            throw await de_DeleteConflictExceptionRes(parsedOutput, context);
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DeleteThingCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteThingCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DeleteThingCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        case "VersionConflictException":
        case "com.amazonaws.iot#VersionConflictException":
            throw await de_VersionConflictExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DeleteThingGroupCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteThingGroupCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DeleteThingGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "VersionConflictException":
        case "com.amazonaws.iot#VersionConflictException":
            throw await de_VersionConflictExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DeleteThingTypeCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteThingTypeCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DeleteThingTypeCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DeleteTopicRuleCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteTopicRuleCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DeleteTopicRuleCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConflictingResourceUpdateException":
        case "com.amazonaws.iot#ConflictingResourceUpdateException":
            throw await de_ConflictingResourceUpdateExceptionRes(parsedOutput, context);
        case "InternalException":
        case "com.amazonaws.iot#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DeleteTopicRuleDestinationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteTopicRuleDestinationCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DeleteTopicRuleDestinationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConflictingResourceUpdateException":
        case "com.amazonaws.iot#ConflictingResourceUpdateException":
            throw await de_ConflictingResourceUpdateExceptionRes(parsedOutput, context);
        case "InternalException":
        case "com.amazonaws.iot#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DeleteV2LoggingLevelCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteV2LoggingLevelCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DeleteV2LoggingLevelCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.iot#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DeprecateThingTypeCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeprecateThingTypeCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DeprecateThingTypeCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DescribeAccountAuditConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DescribeAccountAuditConfigurationCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        auditCheckConfigurations: _json,
        auditNotificationTargetConfigurations: _json,
        roleArn: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_DescribeAccountAuditConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DescribeAuditFindingCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DescribeAuditFindingCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        finding: (_) => de_AuditFinding(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
const de_DescribeAuditFindingCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DescribeAuditMitigationActionsTaskCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DescribeAuditMitigationActionsTaskCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        actionsDefinition: _json,
        auditCheckToActionsMapping: _json,
        endTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        startTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        target: _json,
        taskStatistics: _json,
        taskStatus: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_DescribeAuditMitigationActionsTaskCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DescribeAuditSuppressionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DescribeAuditSuppressionCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        checkName: __expectString,
        description: __expectString,
        expirationDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        resourceIdentifier: _json,
        suppressIndefinitely: __expectBoolean,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_DescribeAuditSuppressionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DescribeAuditTaskCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DescribeAuditTaskCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        auditDetails: _json,
        scheduledAuditName: __expectString,
        taskStartTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        taskStatistics: _json,
        taskStatus: __expectString,
        taskType: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_DescribeAuditTaskCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DescribeAuthorizerCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DescribeAuthorizerCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        authorizerDescription: (_) => de_AuthorizerDescription(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
const de_DescribeAuthorizerCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DescribeBillingGroupCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DescribeBillingGroupCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        billingGroupArn: __expectString,
        billingGroupId: __expectString,
        billingGroupMetadata: (_) => de_BillingGroupMetadata(_, context),
        billingGroupName: __expectString,
        billingGroupProperties: _json,
        version: __expectLong,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_DescribeBillingGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DescribeCACertificateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DescribeCACertificateCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        certificateDescription: (_) => de_CACertificateDescription(_, context),
        registrationConfig: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_DescribeCACertificateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DescribeCertificateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DescribeCertificateCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        certificateDescription: (_) => de_CertificateDescription(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
const de_DescribeCertificateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DescribeCertificateProviderCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DescribeCertificateProviderCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        accountDefaultForOperations: _json,
        certificateProviderArn: __expectString,
        certificateProviderName: __expectString,
        creationDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        lambdaFunctionArn: __expectString,
        lastModifiedDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
    });
    Object.assign(contents, doc);
    return contents;
};
const de_DescribeCertificateProviderCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DescribeCustomMetricCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DescribeCustomMetricCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        creationDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        displayName: __expectString,
        lastModifiedDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        metricArn: __expectString,
        metricName: __expectString,
        metricType: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_DescribeCustomMetricCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DescribeDefaultAuthorizerCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DescribeDefaultAuthorizerCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        authorizerDescription: (_) => de_AuthorizerDescription(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
const de_DescribeDefaultAuthorizerCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DescribeDetectMitigationActionsTaskCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DescribeDetectMitigationActionsTaskCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        taskSummary: (_) => de_DetectMitigationActionsTaskSummary(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
const de_DescribeDetectMitigationActionsTaskCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DescribeDimensionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DescribeDimensionCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        arn: __expectString,
        creationDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        lastModifiedDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        name: __expectString,
        stringValues: _json,
        type: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_DescribeDimensionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DescribeDomainConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DescribeDomainConfigurationCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        authorizerConfig: _json,
        domainConfigurationArn: __expectString,
        domainConfigurationName: __expectString,
        domainConfigurationStatus: __expectString,
        domainName: __expectString,
        domainType: __expectString,
        lastStatusChangeDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        serverCertificates: _json,
        serviceType: __expectString,
        tlsConfig: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_DescribeDomainConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DescribeEndpointCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DescribeEndpointCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        endpointAddress: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_DescribeEndpointCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DescribeEventConfigurationsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DescribeEventConfigurationsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        creationDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        eventConfigurations: _json,
        lastModifiedDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
    });
    Object.assign(contents, doc);
    return contents;
};
const de_DescribeEventConfigurationsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DescribeFleetMetricCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DescribeFleetMetricCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        aggregationField: __expectString,
        aggregationType: _json,
        creationDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        description: __expectString,
        indexName: __expectString,
        lastModifiedDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        metricArn: __expectString,
        metricName: __expectString,
        period: __expectInt32,
        queryString: __expectString,
        queryVersion: __expectString,
        unit: __expectString,
        version: __expectLong,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_DescribeFleetMetricCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DescribeIndexCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DescribeIndexCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        indexName: __expectString,
        indexStatus: __expectString,
        schema: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_DescribeIndexCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DescribeJobCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DescribeJobCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        documentSource: __expectString,
        job: (_) => de_Job(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
const de_DescribeJobCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DescribeJobExecutionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DescribeJobExecutionCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        execution: (_) => de_JobExecution(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
const de_DescribeJobExecutionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DescribeJobTemplateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DescribeJobTemplateCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        abortConfig: (_) => de_AbortConfig(_, context),
        createdAt: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        description: __expectString,
        destinationPackageVersions: _json,
        document: __expectString,
        documentSource: __expectString,
        jobExecutionsRetryConfig: _json,
        jobExecutionsRolloutConfig: (_) => de_JobExecutionsRolloutConfig(_, context),
        jobTemplateArn: __expectString,
        jobTemplateId: __expectString,
        maintenanceWindows: _json,
        presignedUrlConfig: _json,
        timeoutConfig: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_DescribeJobTemplateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DescribeManagedJobTemplateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DescribeManagedJobTemplateCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        description: __expectString,
        document: __expectString,
        documentParameters: _json,
        environments: _json,
        templateArn: __expectString,
        templateName: __expectString,
        templateVersion: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_DescribeManagedJobTemplateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerException":
        case "com.amazonaws.iot#InternalServerException":
            throw await de_InternalServerExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DescribeMitigationActionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DescribeMitigationActionCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        actionArn: __expectString,
        actionId: __expectString,
        actionName: __expectString,
        actionParams: _json,
        actionType: __expectString,
        creationDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        lastModifiedDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        roleArn: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_DescribeMitigationActionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DescribeProvisioningTemplateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DescribeProvisioningTemplateCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        creationDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        defaultVersionId: __expectInt32,
        description: __expectString,
        enabled: __expectBoolean,
        lastModifiedDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        preProvisioningHook: _json,
        provisioningRoleArn: __expectString,
        templateArn: __expectString,
        templateBody: __expectString,
        templateName: __expectString,
        type: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_DescribeProvisioningTemplateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DescribeProvisioningTemplateVersionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DescribeProvisioningTemplateVersionCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        creationDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        isDefaultVersion: __expectBoolean,
        templateBody: __expectString,
        versionId: __expectInt32,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_DescribeProvisioningTemplateVersionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DescribeRoleAliasCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DescribeRoleAliasCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        roleAliasDescription: (_) => de_RoleAliasDescription(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
const de_DescribeRoleAliasCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DescribeScheduledAuditCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DescribeScheduledAuditCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        dayOfMonth: __expectString,
        dayOfWeek: __expectString,
        frequency: __expectString,
        scheduledAuditArn: __expectString,
        scheduledAuditName: __expectString,
        targetCheckNames: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_DescribeScheduledAuditCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DescribeSecurityProfileCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DescribeSecurityProfileCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        additionalMetricsToRetain: _json,
        additionalMetricsToRetainV2: _json,
        alertTargets: _json,
        behaviors: (_) => de_Behaviors(_, context),
        creationDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        lastModifiedDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        metricsExportConfig: _json,
        securityProfileArn: __expectString,
        securityProfileDescription: __expectString,
        securityProfileName: __expectString,
        version: __expectLong,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_DescribeSecurityProfileCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DescribeStreamCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DescribeStreamCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        streamInfo: (_) => de_StreamInfo(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
const de_DescribeStreamCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DescribeThingCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DescribeThingCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        attributes: _json,
        billingGroupName: __expectString,
        defaultClientId: __expectString,
        thingArn: __expectString,
        thingId: __expectString,
        thingName: __expectString,
        thingTypeName: __expectString,
        version: __expectLong,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_DescribeThingCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DescribeThingGroupCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DescribeThingGroupCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        indexName: __expectString,
        queryString: __expectString,
        queryVersion: __expectString,
        status: __expectString,
        thingGroupArn: __expectString,
        thingGroupId: __expectString,
        thingGroupMetadata: (_) => de_ThingGroupMetadata(_, context),
        thingGroupName: __expectString,
        thingGroupProperties: _json,
        version: __expectLong,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_DescribeThingGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DescribeThingRegistrationTaskCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DescribeThingRegistrationTaskCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        creationDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        failureCount: __expectInt32,
        inputFileBucket: __expectString,
        inputFileKey: __expectString,
        lastModifiedDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        message: __expectString,
        percentageProgress: __expectInt32,
        roleArn: __expectString,
        status: __expectString,
        successCount: __expectInt32,
        taskId: __expectString,
        templateBody: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_DescribeThingRegistrationTaskCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DescribeThingTypeCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DescribeThingTypeCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        thingTypeArn: __expectString,
        thingTypeId: __expectString,
        thingTypeMetadata: (_) => de_ThingTypeMetadata(_, context),
        thingTypeName: __expectString,
        thingTypeProperties: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_DescribeThingTypeCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DetachPolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DetachPolicyCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DetachPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DetachPrincipalPolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DetachPrincipalPolicyCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DetachPrincipalPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DetachSecurityProfileCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DetachSecurityProfileCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DetachSecurityProfileCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DetachThingPrincipalCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DetachThingPrincipalCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DetachThingPrincipalCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_DisableTopicRuleCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DisableTopicRuleCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_DisableTopicRuleCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConflictingResourceUpdateException":
        case "com.amazonaws.iot#ConflictingResourceUpdateException":
            throw await de_ConflictingResourceUpdateExceptionRes(parsedOutput, context);
        case "InternalException":
        case "com.amazonaws.iot#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_EnableTopicRuleCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_EnableTopicRuleCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_EnableTopicRuleCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConflictingResourceUpdateException":
        case "com.amazonaws.iot#ConflictingResourceUpdateException":
            throw await de_ConflictingResourceUpdateExceptionRes(parsedOutput, context);
        case "InternalException":
        case "com.amazonaws.iot#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetBehaviorModelTrainingSummariesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetBehaviorModelTrainingSummariesCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        nextToken: __expectString,
        summaries: (_) => de_BehaviorModelTrainingSummaries(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
const de_GetBehaviorModelTrainingSummariesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetBucketsAggregationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetBucketsAggregationCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        buckets: _json,
        totalCount: __expectInt32,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_GetBucketsAggregationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "IndexNotReadyException":
        case "com.amazonaws.iot#IndexNotReadyException":
            throw await de_IndexNotReadyExceptionRes(parsedOutput, context);
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidAggregationException":
        case "com.amazonaws.iot#InvalidAggregationException":
            throw await de_InvalidAggregationExceptionRes(parsedOutput, context);
        case "InvalidQueryException":
        case "com.amazonaws.iot#InvalidQueryException":
            throw await de_InvalidQueryExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetCardinalityCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetCardinalityCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        cardinality: __expectInt32,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_GetCardinalityCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "IndexNotReadyException":
        case "com.amazonaws.iot#IndexNotReadyException":
            throw await de_IndexNotReadyExceptionRes(parsedOutput, context);
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidAggregationException":
        case "com.amazonaws.iot#InvalidAggregationException":
            throw await de_InvalidAggregationExceptionRes(parsedOutput, context);
        case "InvalidQueryException":
        case "com.amazonaws.iot#InvalidQueryException":
            throw await de_InvalidQueryExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetEffectivePoliciesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetEffectivePoliciesCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        effectivePolicies: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_GetEffectivePoliciesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetIndexingConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetIndexingConfigurationCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        thingGroupIndexingConfiguration: _json,
        thingIndexingConfiguration: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_GetIndexingConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetJobDocumentCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetJobDocumentCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        document: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_GetJobDocumentCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetLoggingOptionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetLoggingOptionsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        logLevel: __expectString,
        roleArn: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_GetLoggingOptionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.iot#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetOTAUpdateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetOTAUpdateCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        otaUpdateInfo: (_) => de_OTAUpdateInfo(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
const de_GetOTAUpdateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetPackageCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetPackageCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        creationDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        defaultVersionName: __expectString,
        description: __expectString,
        lastModifiedDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        packageArn: __expectString,
        packageName: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_GetPackageCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerException":
        case "com.amazonaws.iot#InternalServerException":
            throw await de_InternalServerExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.iot#ValidationException":
            throw await de_ValidationExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetPackageConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetPackageConfigurationCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        versionUpdateByJobsConfig: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_GetPackageConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerException":
        case "com.amazonaws.iot#InternalServerException":
            throw await de_InternalServerExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetPackageVersionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetPackageVersionCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        attributes: _json,
        creationDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        description: __expectString,
        errorReason: __expectString,
        lastModifiedDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        packageName: __expectString,
        packageVersionArn: __expectString,
        status: __expectString,
        versionName: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_GetPackageVersionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerException":
        case "com.amazonaws.iot#InternalServerException":
            throw await de_InternalServerExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.iot#ValidationException":
            throw await de_ValidationExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetPercentilesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetPercentilesCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        percentiles: (_) => de_Percentiles(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
const de_GetPercentilesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "IndexNotReadyException":
        case "com.amazonaws.iot#IndexNotReadyException":
            throw await de_IndexNotReadyExceptionRes(parsedOutput, context);
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidAggregationException":
        case "com.amazonaws.iot#InvalidAggregationException":
            throw await de_InvalidAggregationExceptionRes(parsedOutput, context);
        case "InvalidQueryException":
        case "com.amazonaws.iot#InvalidQueryException":
            throw await de_InvalidQueryExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetPolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetPolicyCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        creationDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        defaultVersionId: __expectString,
        generationId: __expectString,
        lastModifiedDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        policyArn: __expectString,
        policyDocument: __expectString,
        policyName: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_GetPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetPolicyVersionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetPolicyVersionCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        creationDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        generationId: __expectString,
        isDefaultVersion: __expectBoolean,
        lastModifiedDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        policyArn: __expectString,
        policyDocument: __expectString,
        policyName: __expectString,
        policyVersionId: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_GetPolicyVersionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetRegistrationCodeCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetRegistrationCodeCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        registrationCode: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_GetRegistrationCodeCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetStatisticsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetStatisticsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        statistics: (_) => de_Statistics(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
const de_GetStatisticsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "IndexNotReadyException":
        case "com.amazonaws.iot#IndexNotReadyException":
            throw await de_IndexNotReadyExceptionRes(parsedOutput, context);
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidAggregationException":
        case "com.amazonaws.iot#InvalidAggregationException":
            throw await de_InvalidAggregationExceptionRes(parsedOutput, context);
        case "InvalidQueryException":
        case "com.amazonaws.iot#InvalidQueryException":
            throw await de_InvalidQueryExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetTopicRuleCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetTopicRuleCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        rule: (_) => de_TopicRule(_, context),
        ruleArn: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_GetTopicRuleCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.iot#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetTopicRuleDestinationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetTopicRuleDestinationCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        topicRuleDestination: (_) => de_TopicRuleDestination(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
const de_GetTopicRuleDestinationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.iot#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetV2LoggingOptionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetV2LoggingOptionsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        defaultLogLevel: __expectString,
        disableAllLogs: __expectBoolean,
        roleArn: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_GetV2LoggingOptionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.iot#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "NotConfiguredException":
        case "com.amazonaws.iot#NotConfiguredException":
            throw await de_NotConfiguredExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_ListActiveViolationsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListActiveViolationsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        activeViolations: (_) => de_ActiveViolations(_, context),
        nextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_ListActiveViolationsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_ListAttachedPoliciesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListAttachedPoliciesCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        nextMarker: __expectString,
        policies: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_ListAttachedPoliciesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_ListAuditFindingsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListAuditFindingsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        findings: (_) => de_AuditFindings(_, context),
        nextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_ListAuditFindingsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_ListAuditMitigationActionsExecutionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListAuditMitigationActionsExecutionsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        actionsExecutions: (_) => de_AuditMitigationActionExecutionMetadataList(_, context),
        nextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_ListAuditMitigationActionsExecutionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_ListAuditMitigationActionsTasksCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListAuditMitigationActionsTasksCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        nextToken: __expectString,
        tasks: (_) => de_AuditMitigationActionsTaskMetadataList(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
const de_ListAuditMitigationActionsTasksCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_ListAuditSuppressionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListAuditSuppressionsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        nextToken: __expectString,
        suppressions: (_) => de_AuditSuppressionList(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
const de_ListAuditSuppressionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_ListAuditTasksCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListAuditTasksCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        nextToken: __expectString,
        tasks: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_ListAuditTasksCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_ListAuthorizersCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListAuthorizersCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        authorizers: _json,
        nextMarker: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_ListAuthorizersCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_ListBillingGroupsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListBillingGroupsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        billingGroups: _json,
        nextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_ListBillingGroupsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_ListCACertificatesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListCACertificatesCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        certificates: (_) => de_CACertificates(_, context),
        nextMarker: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_ListCACertificatesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_ListCertificateProvidersCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListCertificateProvidersCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        certificateProviders: _json,
        nextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_ListCertificateProvidersCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_ListCertificatesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListCertificatesCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        certificates: (_) => de_Certificates(_, context),
        nextMarker: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_ListCertificatesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_ListCertificatesByCACommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListCertificatesByCACommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        certificates: (_) => de_Certificates(_, context),
        nextMarker: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_ListCertificatesByCACommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_ListCustomMetricsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListCustomMetricsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        metricNames: _json,
        nextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_ListCustomMetricsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_ListDetectMitigationActionsExecutionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListDetectMitigationActionsExecutionsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        actionsExecutions: (_) => de_DetectMitigationActionExecutionList(_, context),
        nextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_ListDetectMitigationActionsExecutionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_ListDetectMitigationActionsTasksCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListDetectMitigationActionsTasksCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        nextToken: __expectString,
        tasks: (_) => de_DetectMitigationActionsTaskSummaryList(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
const de_ListDetectMitigationActionsTasksCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_ListDimensionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListDimensionsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        dimensionNames: _json,
        nextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_ListDimensionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_ListDomainConfigurationsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListDomainConfigurationsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        domainConfigurations: _json,
        nextMarker: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_ListDomainConfigurationsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_ListFleetMetricsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListFleetMetricsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        fleetMetrics: _json,
        nextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_ListFleetMetricsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_ListIndicesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListIndicesCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        indexNames: _json,
        nextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_ListIndicesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_ListJobExecutionsForJobCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListJobExecutionsForJobCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        executionSummaries: (_) => de_JobExecutionSummaryForJobList(_, context),
        nextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_ListJobExecutionsForJobCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_ListJobExecutionsForThingCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListJobExecutionsForThingCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        executionSummaries: (_) => de_JobExecutionSummaryForThingList(_, context),
        nextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_ListJobExecutionsForThingCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_ListJobsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListJobsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        jobs: (_) => de_JobSummaryList(_, context),
        nextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_ListJobsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_ListJobTemplatesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListJobTemplatesCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        jobTemplates: (_) => de_JobTemplateSummaryList(_, context),
        nextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_ListJobTemplatesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_ListManagedJobTemplatesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListManagedJobTemplatesCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        managedJobTemplates: _json,
        nextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_ListManagedJobTemplatesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerException":
        case "com.amazonaws.iot#InternalServerException":
            throw await de_InternalServerExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_ListMetricValuesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListMetricValuesCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        metricDatumList: (_) => de_MetricDatumList(_, context),
        nextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_ListMetricValuesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_ListMitigationActionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListMitigationActionsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        actionIdentifiers: (_) => de_MitigationActionIdentifierList(_, context),
        nextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_ListMitigationActionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_ListOTAUpdatesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListOTAUpdatesCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        nextToken: __expectString,
        otaUpdates: (_) => de_OTAUpdatesSummary(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
const de_ListOTAUpdatesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_ListOutgoingCertificatesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListOutgoingCertificatesCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        nextMarker: __expectString,
        outgoingCertificates: (_) => de_OutgoingCertificates(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
const de_ListOutgoingCertificatesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_ListPackagesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListPackagesCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        nextToken: __expectString,
        packageSummaries: (_) => de_PackageSummaryList(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
const de_ListPackagesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerException":
        case "com.amazonaws.iot#InternalServerException":
            throw await de_InternalServerExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.iot#ValidationException":
            throw await de_ValidationExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_ListPackageVersionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListPackageVersionsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        nextToken: __expectString,
        packageVersionSummaries: (_) => de_PackageVersionSummaryList(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
const de_ListPackageVersionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerException":
        case "com.amazonaws.iot#InternalServerException":
            throw await de_InternalServerExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.iot#ValidationException":
            throw await de_ValidationExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_ListPoliciesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListPoliciesCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        nextMarker: __expectString,
        policies: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_ListPoliciesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_ListPolicyPrincipalsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListPolicyPrincipalsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        nextMarker: __expectString,
        principals: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_ListPolicyPrincipalsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_ListPolicyVersionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListPolicyVersionsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        policyVersions: (_) => de_PolicyVersions(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
const de_ListPolicyVersionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_ListPrincipalPoliciesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListPrincipalPoliciesCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        nextMarker: __expectString,
        policies: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_ListPrincipalPoliciesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_ListPrincipalThingsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListPrincipalThingsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        nextToken: __expectString,
        things: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_ListPrincipalThingsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_ListProvisioningTemplatesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListProvisioningTemplatesCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        nextToken: __expectString,
        templates: (_) => de_ProvisioningTemplateListing(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
const de_ListProvisioningTemplatesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_ListProvisioningTemplateVersionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListProvisioningTemplateVersionsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        nextToken: __expectString,
        versions: (_) => de_ProvisioningTemplateVersionListing(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
const de_ListProvisioningTemplateVersionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_ListRelatedResourcesForAuditFindingCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListRelatedResourcesForAuditFindingCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        nextToken: __expectString,
        relatedResources: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_ListRelatedResourcesForAuditFindingCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_ListRoleAliasesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListRoleAliasesCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        nextMarker: __expectString,
        roleAliases: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_ListRoleAliasesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_ListScheduledAuditsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListScheduledAuditsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        nextToken: __expectString,
        scheduledAudits: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_ListScheduledAuditsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_ListSecurityProfilesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListSecurityProfilesCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        nextToken: __expectString,
        securityProfileIdentifiers: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_ListSecurityProfilesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_ListSecurityProfilesForTargetCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListSecurityProfilesForTargetCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        nextToken: __expectString,
        securityProfileTargetMappings: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_ListSecurityProfilesForTargetCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_ListStreamsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListStreamsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        nextToken: __expectString,
        streams: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_ListStreamsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_ListTagsForResourceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListTagsForResourceCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        nextToken: __expectString,
        tags: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_ListTagsForResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_ListTargetsForPolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListTargetsForPolicyCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        nextMarker: __expectString,
        targets: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_ListTargetsForPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_ListTargetsForSecurityProfileCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListTargetsForSecurityProfileCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        nextToken: __expectString,
        securityProfileTargets: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_ListTargetsForSecurityProfileCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_ListThingGroupsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListThingGroupsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        nextToken: __expectString,
        thingGroups: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_ListThingGroupsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_ListThingGroupsForThingCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListThingGroupsForThingCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        nextToken: __expectString,
        thingGroups: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_ListThingGroupsForThingCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_ListThingPrincipalsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListThingPrincipalsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        nextToken: __expectString,
        principals: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_ListThingPrincipalsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_ListThingRegistrationTaskReportsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListThingRegistrationTaskReportsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        nextToken: __expectString,
        reportType: __expectString,
        resourceLinks: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_ListThingRegistrationTaskReportsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_ListThingRegistrationTasksCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListThingRegistrationTasksCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        nextToken: __expectString,
        taskIds: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_ListThingRegistrationTasksCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_ListThingsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListThingsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        nextToken: __expectString,
        things: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_ListThingsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_ListThingsInBillingGroupCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListThingsInBillingGroupCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        nextToken: __expectString,
        things: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_ListThingsInBillingGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_ListThingsInThingGroupCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListThingsInThingGroupCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        nextToken: __expectString,
        things: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_ListThingsInThingGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_ListThingTypesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListThingTypesCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        nextToken: __expectString,
        thingTypes: (_) => de_ThingTypeList(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
const de_ListThingTypesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_ListTopicRuleDestinationsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListTopicRuleDestinationsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        destinationSummaries: (_) => de_TopicRuleDestinationSummaries(_, context),
        nextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_ListTopicRuleDestinationsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.iot#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_ListTopicRulesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListTopicRulesCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        nextToken: __expectString,
        rules: (_) => de_TopicRuleList(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
const de_ListTopicRulesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.iot#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_ListV2LoggingLevelsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListV2LoggingLevelsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        logTargetConfigurations: _json,
        nextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_ListV2LoggingLevelsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.iot#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "NotConfiguredException":
        case "com.amazonaws.iot#NotConfiguredException":
            throw await de_NotConfiguredExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_ListViolationEventsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListViolationEventsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        nextToken: __expectString,
        violationEvents: (_) => de_ViolationEvents(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
const de_ListViolationEventsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_PutVerificationStateOnViolationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_PutVerificationStateOnViolationCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_PutVerificationStateOnViolationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_RegisterCACertificateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_RegisterCACertificateCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        certificateArn: __expectString,
        certificateId: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_RegisterCACertificateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "CertificateValidationException":
        case "com.amazonaws.iot#CertificateValidationException":
            throw await de_CertificateValidationExceptionRes(parsedOutput, context);
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "RegistrationCodeValidationException":
        case "com.amazonaws.iot#RegistrationCodeValidationException":
            throw await de_RegistrationCodeValidationExceptionRes(parsedOutput, context);
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            throw await de_ResourceAlreadyExistsExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_RegisterCertificateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_RegisterCertificateCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        certificateArn: __expectString,
        certificateId: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_RegisterCertificateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "CertificateConflictException":
        case "com.amazonaws.iot#CertificateConflictException":
            throw await de_CertificateConflictExceptionRes(parsedOutput, context);
        case "CertificateStateException":
        case "com.amazonaws.iot#CertificateStateException":
            throw await de_CertificateStateExceptionRes(parsedOutput, context);
        case "CertificateValidationException":
        case "com.amazonaws.iot#CertificateValidationException":
            throw await de_CertificateValidationExceptionRes(parsedOutput, context);
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            throw await de_ResourceAlreadyExistsExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_RegisterCertificateWithoutCACommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_RegisterCertificateWithoutCACommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        certificateArn: __expectString,
        certificateId: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_RegisterCertificateWithoutCACommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "CertificateStateException":
        case "com.amazonaws.iot#CertificateStateException":
            throw await de_CertificateStateExceptionRes(parsedOutput, context);
        case "CertificateValidationException":
        case "com.amazonaws.iot#CertificateValidationException":
            throw await de_CertificateValidationExceptionRes(parsedOutput, context);
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            throw await de_ResourceAlreadyExistsExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_RegisterThingCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_RegisterThingCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        certificatePem: __expectString,
        resourceArns: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_RegisterThingCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConflictingResourceUpdateException":
        case "com.amazonaws.iot#ConflictingResourceUpdateException":
            throw await de_ConflictingResourceUpdateExceptionRes(parsedOutput, context);
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceRegistrationFailureException":
        case "com.amazonaws.iot#ResourceRegistrationFailureException":
            throw await de_ResourceRegistrationFailureExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_RejectCertificateTransferCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_RejectCertificateTransferCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_RejectCertificateTransferCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "TransferAlreadyCompletedException":
        case "com.amazonaws.iot#TransferAlreadyCompletedException":
            throw await de_TransferAlreadyCompletedExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_RemoveThingFromBillingGroupCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_RemoveThingFromBillingGroupCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_RemoveThingFromBillingGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_RemoveThingFromThingGroupCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_RemoveThingFromThingGroupCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_RemoveThingFromThingGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_ReplaceTopicRuleCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ReplaceTopicRuleCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_ReplaceTopicRuleCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConflictingResourceUpdateException":
        case "com.amazonaws.iot#ConflictingResourceUpdateException":
            throw await de_ConflictingResourceUpdateExceptionRes(parsedOutput, context);
        case "InternalException":
        case "com.amazonaws.iot#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "SqlParseException":
        case "com.amazonaws.iot#SqlParseException":
            throw await de_SqlParseExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_SearchIndexCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_SearchIndexCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        nextToken: __expectString,
        thingGroups: _json,
        things: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_SearchIndexCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "IndexNotReadyException":
        case "com.amazonaws.iot#IndexNotReadyException":
            throw await de_IndexNotReadyExceptionRes(parsedOutput, context);
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidQueryException":
        case "com.amazonaws.iot#InvalidQueryException":
            throw await de_InvalidQueryExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_SetDefaultAuthorizerCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_SetDefaultAuthorizerCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        authorizerArn: __expectString,
        authorizerName: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_SetDefaultAuthorizerCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            throw await de_ResourceAlreadyExistsExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_SetDefaultPolicyVersionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_SetDefaultPolicyVersionCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_SetDefaultPolicyVersionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_SetLoggingOptionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_SetLoggingOptionsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_SetLoggingOptionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.iot#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_SetV2LoggingLevelCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_SetV2LoggingLevelCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_SetV2LoggingLevelCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.iot#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotConfiguredException":
        case "com.amazonaws.iot#NotConfiguredException":
            throw await de_NotConfiguredExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_SetV2LoggingOptionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_SetV2LoggingOptionsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_SetV2LoggingOptionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.iot#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_StartAuditMitigationActionsTaskCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_StartAuditMitigationActionsTaskCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        taskId: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_StartAuditMitigationActionsTaskCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "TaskAlreadyExistsException":
        case "com.amazonaws.iot#TaskAlreadyExistsException":
            throw await de_TaskAlreadyExistsExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_StartDetectMitigationActionsTaskCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_StartDetectMitigationActionsTaskCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        taskId: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_StartDetectMitigationActionsTaskCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "TaskAlreadyExistsException":
        case "com.amazonaws.iot#TaskAlreadyExistsException":
            throw await de_TaskAlreadyExistsExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_StartOnDemandAuditTaskCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_StartOnDemandAuditTaskCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        taskId: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_StartOnDemandAuditTaskCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_StartThingRegistrationTaskCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_StartThingRegistrationTaskCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        taskId: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_StartThingRegistrationTaskCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_StopThingRegistrationTaskCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_StopThingRegistrationTaskCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_StopThingRegistrationTaskCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_TagResourceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_TagResourceCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_TagResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_TestAuthorizationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_TestAuthorizationCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        authResults: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_TestAuthorizationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_TestInvokeAuthorizerCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_TestInvokeAuthorizerCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        disconnectAfterInSeconds: __expectInt32,
        isAuthenticated: __expectBoolean,
        policyDocuments: _json,
        principalId: __expectString,
        refreshAfterInSeconds: __expectInt32,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_TestInvokeAuthorizerCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "InvalidResponseException":
        case "com.amazonaws.iot#InvalidResponseException":
            throw await de_InvalidResponseExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_TransferCertificateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_TransferCertificateCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        transferredCertificateArn: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_TransferCertificateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "CertificateStateException":
        case "com.amazonaws.iot#CertificateStateException":
            throw await de_CertificateStateExceptionRes(parsedOutput, context);
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "TransferConflictException":
        case "com.amazonaws.iot#TransferConflictException":
            throw await de_TransferConflictExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_UntagResourceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UntagResourceCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_UntagResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_UpdateAccountAuditConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateAccountAuditConfigurationCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_UpdateAccountAuditConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_UpdateAuditSuppressionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateAuditSuppressionCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_UpdateAuditSuppressionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_UpdateAuthorizerCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateAuthorizerCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        authorizerArn: __expectString,
        authorizerName: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_UpdateAuthorizerCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_UpdateBillingGroupCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateBillingGroupCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        version: __expectLong,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_UpdateBillingGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "VersionConflictException":
        case "com.amazonaws.iot#VersionConflictException":
            throw await de_VersionConflictExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_UpdateCACertificateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateCACertificateCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_UpdateCACertificateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_UpdateCertificateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateCertificateCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_UpdateCertificateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "CertificateStateException":
        case "com.amazonaws.iot#CertificateStateException":
            throw await de_CertificateStateExceptionRes(parsedOutput, context);
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_UpdateCertificateProviderCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateCertificateProviderCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        certificateProviderArn: __expectString,
        certificateProviderName: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_UpdateCertificateProviderCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_UpdateCustomMetricCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateCustomMetricCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        creationDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        displayName: __expectString,
        lastModifiedDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        metricArn: __expectString,
        metricName: __expectString,
        metricType: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_UpdateCustomMetricCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_UpdateDimensionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateDimensionCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        arn: __expectString,
        creationDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        lastModifiedDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        name: __expectString,
        stringValues: _json,
        type: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_UpdateDimensionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_UpdateDomainConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateDomainConfigurationCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        domainConfigurationArn: __expectString,
        domainConfigurationName: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_UpdateDomainConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "CertificateValidationException":
        case "com.amazonaws.iot#CertificateValidationException":
            throw await de_CertificateValidationExceptionRes(parsedOutput, context);
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_UpdateDynamicThingGroupCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateDynamicThingGroupCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        version: __expectLong,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_UpdateDynamicThingGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidQueryException":
        case "com.amazonaws.iot#InvalidQueryException":
            throw await de_InvalidQueryExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "VersionConflictException":
        case "com.amazonaws.iot#VersionConflictException":
            throw await de_VersionConflictExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_UpdateEventConfigurationsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateEventConfigurationsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_UpdateEventConfigurationsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_UpdateFleetMetricCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateFleetMetricCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_UpdateFleetMetricCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "IndexNotReadyException":
        case "com.amazonaws.iot#IndexNotReadyException":
            throw await de_IndexNotReadyExceptionRes(parsedOutput, context);
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidAggregationException":
        case "com.amazonaws.iot#InvalidAggregationException":
            throw await de_InvalidAggregationExceptionRes(parsedOutput, context);
        case "InvalidQueryException":
        case "com.amazonaws.iot#InvalidQueryException":
            throw await de_InvalidQueryExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        case "VersionConflictException":
        case "com.amazonaws.iot#VersionConflictException":
            throw await de_VersionConflictExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_UpdateIndexingConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateIndexingConfigurationCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_UpdateIndexingConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_UpdateJobCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateJobCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_UpdateJobCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_UpdateMitigationActionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateMitigationActionCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        actionArn: __expectString,
        actionId: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_UpdateMitigationActionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_UpdatePackageCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdatePackageCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_UpdatePackageCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConflictException":
        case "com.amazonaws.iot#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "InternalServerException":
        case "com.amazonaws.iot#InternalServerException":
            throw await de_InternalServerExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.iot#ValidationException":
            throw await de_ValidationExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_UpdatePackageConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdatePackageConfigurationCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_UpdatePackageConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConflictException":
        case "com.amazonaws.iot#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "InternalServerException":
        case "com.amazonaws.iot#InternalServerException":
            throw await de_InternalServerExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.iot#ValidationException":
            throw await de_ValidationExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_UpdatePackageVersionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdatePackageVersionCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_UpdatePackageVersionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConflictException":
        case "com.amazonaws.iot#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "InternalServerException":
        case "com.amazonaws.iot#InternalServerException":
            throw await de_InternalServerExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.iot#ValidationException":
            throw await de_ValidationExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_UpdateProvisioningTemplateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateProvisioningTemplateCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_UpdateProvisioningTemplateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConflictingResourceUpdateException":
        case "com.amazonaws.iot#ConflictingResourceUpdateException":
            throw await de_ConflictingResourceUpdateExceptionRes(parsedOutput, context);
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_UpdateRoleAliasCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateRoleAliasCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        roleAlias: __expectString,
        roleAliasArn: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_UpdateRoleAliasCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_UpdateScheduledAuditCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateScheduledAuditCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        scheduledAuditArn: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_UpdateScheduledAuditCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_UpdateSecurityProfileCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateSecurityProfileCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        additionalMetricsToRetain: _json,
        additionalMetricsToRetainV2: _json,
        alertTargets: _json,
        behaviors: (_) => de_Behaviors(_, context),
        creationDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        lastModifiedDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        metricsExportConfig: _json,
        securityProfileArn: __expectString,
        securityProfileDescription: __expectString,
        securityProfileName: __expectString,
        version: __expectLong,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_UpdateSecurityProfileCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "VersionConflictException":
        case "com.amazonaws.iot#VersionConflictException":
            throw await de_VersionConflictExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_UpdateStreamCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateStreamCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        description: __expectString,
        streamArn: __expectString,
        streamId: __expectString,
        streamVersion: __expectInt32,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_UpdateStreamCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_UpdateThingCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateThingCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_UpdateThingCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        case "VersionConflictException":
        case "com.amazonaws.iot#VersionConflictException":
            throw await de_VersionConflictExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_UpdateThingGroupCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateThingGroupCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        version: __expectLong,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_UpdateThingGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "VersionConflictException":
        case "com.amazonaws.iot#VersionConflictException":
            throw await de_VersionConflictExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_UpdateThingGroupsForThingCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateThingGroupsForThingCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_UpdateThingGroupsForThingCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_UpdateTopicRuleDestinationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateTopicRuleDestinationCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_UpdateTopicRuleDestinationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConflictingResourceUpdateException":
        case "com.amazonaws.iot#ConflictingResourceUpdateException":
            throw await de_ConflictingResourceUpdateExceptionRes(parsedOutput, context);
        case "InternalException":
        case "com.amazonaws.iot#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_ValidateSecurityProfileBehaviorsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ValidateSecurityProfileBehaviorsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        valid: __expectBoolean,
        validationErrors: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_ValidateSecurityProfileBehaviorsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const throwDefaultError = withBaseException(__BaseException);
const de_CertificateConflictExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new CertificateConflictException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_CertificateStateExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new CertificateStateException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_CertificateValidationExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new CertificateValidationException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ConflictExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
        resourceId: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ConflictException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ConflictingResourceUpdateExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ConflictingResourceUpdateException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_DeleteConflictExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new DeleteConflictException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_IndexNotReadyExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new IndexNotReadyException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_InternalExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new InternalException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_InternalFailureExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new InternalFailureException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_InternalServerExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new InternalServerException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_InvalidAggregationExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new InvalidAggregationException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_InvalidQueryExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new InvalidQueryException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_InvalidRequestExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new InvalidRequestException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_InvalidResponseExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new InvalidResponseException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_InvalidStateTransitionExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new InvalidStateTransitionException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_LimitExceededExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new LimitExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_MalformedPolicyExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new MalformedPolicyException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_NotConfiguredExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new NotConfiguredException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_RegistrationCodeValidationExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new RegistrationCodeValidationException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ResourceAlreadyExistsExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
        resourceArn: __expectString,
        resourceId: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ResourceAlreadyExistsException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ResourceNotFoundExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ResourceNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ResourceRegistrationFailureExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ResourceRegistrationFailureException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ServiceQuotaExceededExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ServiceQuotaExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ServiceUnavailableExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ServiceUnavailableException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_SqlParseExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new SqlParseException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_TaskAlreadyExistsExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new TaskAlreadyExistsException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ThrottlingExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ThrottlingException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_TransferAlreadyCompletedExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new TransferAlreadyCompletedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_TransferConflictExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new TransferConflictException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_UnauthorizedExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new UnauthorizedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ValidationExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ValidationException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_VersionConflictExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new VersionConflictException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_VersionsLimitExceededExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new VersionsLimitExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const se_AbortConfig = (input, context) => {
    return take(input, {
        criteriaList: (_) => se_AbortCriteriaList(_, context),
    });
};
const se_AbortCriteria = (input, context) => {
    return take(input, {
        action: [],
        failureType: [],
        minNumberOfExecutedThings: [],
        thresholdPercentage: __serializeFloat,
    });
};
const se_AbortCriteriaList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_AbortCriteria(entry, context);
    });
};
const se_AwsJobAbortConfig = (input, context) => {
    return take(input, {
        abortCriteriaList: (_) => se_AwsJobAbortCriteriaList(_, context),
    });
};
const se_AwsJobAbortCriteria = (input, context) => {
    return take(input, {
        action: [],
        failureType: [],
        minNumberOfExecutedThings: [],
        thresholdPercentage: __serializeFloat,
    });
};
const se_AwsJobAbortCriteriaList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_AwsJobAbortCriteria(entry, context);
    });
};
const se_AwsJobExecutionsRolloutConfig = (input, context) => {
    return take(input, {
        exponentialRate: (_) => se_AwsJobExponentialRolloutRate(_, context),
        maximumPerMinute: [],
    });
};
const se_AwsJobExponentialRolloutRate = (input, context) => {
    return take(input, {
        baseRatePerMinute: [],
        incrementFactor: __serializeFloat,
        rateIncreaseCriteria: _json,
    });
};
const se_Behavior = (input, context) => {
    return take(input, {
        criteria: (_) => se_BehaviorCriteria(_, context),
        exportMetric: [],
        metric: [],
        metricDimension: _json,
        name: [],
        suppressAlerts: [],
    });
};
const se_BehaviorCriteria = (input, context) => {
    return take(input, {
        comparisonOperator: [],
        consecutiveDatapointsToAlarm: [],
        consecutiveDatapointsToClear: [],
        durationSeconds: [],
        mlDetectionConfig: _json,
        statisticalThreshold: _json,
        value: (_) => se_MetricValue(_, context),
    });
};
const se_Behaviors = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_Behavior(entry, context);
    });
};
const se_CodeSigning = (input, context) => {
    return take(input, {
        awsSignerJobId: [],
        customCodeSigning: (_) => se_CustomCodeSigning(_, context),
        startSigningJobParameter: _json,
    });
};
const se_CodeSigningSignature = (input, context) => {
    return take(input, {
        inlineDocument: context.base64Encoder,
    });
};
const se_CustomCodeSigning = (input, context) => {
    return take(input, {
        certificateChain: _json,
        hashAlgorithm: [],
        signature: (_) => se_CodeSigningSignature(_, context),
        signatureAlgorithm: [],
    });
};
const se_ExponentialRolloutRate = (input, context) => {
    return take(input, {
        baseRatePerMinute: [],
        incrementFactor: __serializeFloat,
        rateIncreaseCriteria: _json,
    });
};
const se_JobExecutionsRolloutConfig = (input, context) => {
    return take(input, {
        exponentialRate: (_) => se_ExponentialRolloutRate(_, context),
        maximumPerMinute: [],
    });
};
const se_MetricValue = (input, context) => {
    return take(input, {
        cidrs: _json,
        count: [],
        number: __serializeFloat,
        numbers: (_) => se_NumberList(_, context),
        ports: _json,
        strings: _json,
    });
};
const se_MqttContext = (input, context) => {
    return take(input, {
        clientId: [],
        password: context.base64Encoder,
        username: [],
    });
};
const se_NumberList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return __serializeFloat(entry);
    });
};
const se_OTAUpdateFile = (input, context) => {
    return take(input, {
        attributes: _json,
        codeSigning: (_) => se_CodeSigning(_, context),
        fileLocation: _json,
        fileName: [],
        fileType: [],
        fileVersion: [],
    });
};
const se_OTAUpdateFiles = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_OTAUpdateFile(entry, context);
    });
};
const se_PercentList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return __serializeFloat(entry);
    });
};
const se_ViolationEventOccurrenceRange = (input, context) => {
    return take(input, {
        endTime: (_) => Math.round(_.getTime() / 1000),
        startTime: (_) => Math.round(_.getTime() / 1000),
    });
};
const de_AbortConfig = (output, context) => {
    return take(output, {
        criteriaList: (_) => de_AbortCriteriaList(_, context),
    });
};
const de_AbortCriteria = (output, context) => {
    return take(output, {
        action: __expectString,
        failureType: __expectString,
        minNumberOfExecutedThings: __expectInt32,
        thresholdPercentage: __limitedParseDouble,
    });
};
const de_AbortCriteriaList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AbortCriteria(entry, context);
    });
    return retVal;
};
const de_ActiveViolation = (output, context) => {
    return take(output, {
        behavior: (_) => de_Behavior(_, context),
        lastViolationTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        lastViolationValue: (_) => de_MetricValue(_, context),
        securityProfileName: __expectString,
        thingName: __expectString,
        verificationState: __expectString,
        verificationStateDescription: __expectString,
        violationEventAdditionalInfo: _json,
        violationId: __expectString,
        violationStartTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
    });
};
const de_ActiveViolations = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ActiveViolation(entry, context);
    });
    return retVal;
};
const de_AuditFinding = (output, context) => {
    return take(output, {
        checkName: __expectString,
        findingId: __expectString,
        findingTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        isSuppressed: __expectBoolean,
        nonCompliantResource: _json,
        reasonForNonCompliance: __expectString,
        reasonForNonComplianceCode: __expectString,
        relatedResources: _json,
        severity: __expectString,
        taskId: __expectString,
        taskStartTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
    });
};
const de_AuditFindings = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AuditFinding(entry, context);
    });
    return retVal;
};
const de_AuditMitigationActionExecutionMetadata = (output, context) => {
    return take(output, {
        actionId: __expectString,
        actionName: __expectString,
        endTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        errorCode: __expectString,
        findingId: __expectString,
        message: __expectString,
        startTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        status: __expectString,
        taskId: __expectString,
    });
};
const de_AuditMitigationActionExecutionMetadataList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AuditMitigationActionExecutionMetadata(entry, context);
    });
    return retVal;
};
const de_AuditMitigationActionsTaskMetadata = (output, context) => {
    return take(output, {
        startTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        taskId: __expectString,
        taskStatus: __expectString,
    });
};
const de_AuditMitigationActionsTaskMetadataList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AuditMitigationActionsTaskMetadata(entry, context);
    });
    return retVal;
};
const de_AuditSuppression = (output, context) => {
    return take(output, {
        checkName: __expectString,
        description: __expectString,
        expirationDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        resourceIdentifier: _json,
        suppressIndefinitely: __expectBoolean,
    });
};
const de_AuditSuppressionList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AuditSuppression(entry, context);
    });
    return retVal;
};
const de_AuthorizerDescription = (output, context) => {
    return take(output, {
        authorizerArn: __expectString,
        authorizerFunctionArn: __expectString,
        authorizerName: __expectString,
        creationDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        enableCachingForHttp: __expectBoolean,
        lastModifiedDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        signingDisabled: __expectBoolean,
        status: __expectString,
        tokenKeyName: __expectString,
        tokenSigningPublicKeys: _json,
    });
};
const de_AwsJobExecutionsRolloutConfig = (output, context) => {
    return take(output, {
        exponentialRate: (_) => de_AwsJobExponentialRolloutRate(_, context),
        maximumPerMinute: __expectInt32,
    });
};
const de_AwsJobExponentialRolloutRate = (output, context) => {
    return take(output, {
        baseRatePerMinute: __expectInt32,
        incrementFactor: __limitedParseDouble,
        rateIncreaseCriteria: _json,
    });
};
const de_Behavior = (output, context) => {
    return take(output, {
        criteria: (_) => de_BehaviorCriteria(_, context),
        exportMetric: __expectBoolean,
        metric: __expectString,
        metricDimension: _json,
        name: __expectString,
        suppressAlerts: __expectBoolean,
    });
};
const de_BehaviorCriteria = (output, context) => {
    return take(output, {
        comparisonOperator: __expectString,
        consecutiveDatapointsToAlarm: __expectInt32,
        consecutiveDatapointsToClear: __expectInt32,
        durationSeconds: __expectInt32,
        mlDetectionConfig: _json,
        statisticalThreshold: _json,
        value: (_) => de_MetricValue(_, context),
    });
};
const de_BehaviorModelTrainingSummaries = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_BehaviorModelTrainingSummary(entry, context);
    });
    return retVal;
};
const de_BehaviorModelTrainingSummary = (output, context) => {
    return take(output, {
        behaviorName: __expectString,
        datapointsCollectionPercentage: __limitedParseDouble,
        lastModelRefreshDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        modelStatus: __expectString,
        securityProfileName: __expectString,
        trainingDataCollectionStartDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
    });
};
const de_Behaviors = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Behavior(entry, context);
    });
    return retVal;
};
const de_BillingGroupMetadata = (output, context) => {
    return take(output, {
        creationDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
    });
};
const de_CACertificate = (output, context) => {
    return take(output, {
        certificateArn: __expectString,
        certificateId: __expectString,
        creationDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        status: __expectString,
    });
};
const de_CACertificateDescription = (output, context) => {
    return take(output, {
        autoRegistrationStatus: __expectString,
        certificateArn: __expectString,
        certificateId: __expectString,
        certificateMode: __expectString,
        certificatePem: __expectString,
        creationDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        customerVersion: __expectInt32,
        generationId: __expectString,
        lastModifiedDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        ownedBy: __expectString,
        status: __expectString,
        validity: (_) => de_CertificateValidity(_, context),
    });
};
const de_CACertificates = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_CACertificate(entry, context);
    });
    return retVal;
};
const de_Certificate = (output, context) => {
    return take(output, {
        certificateArn: __expectString,
        certificateId: __expectString,
        certificateMode: __expectString,
        creationDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        status: __expectString,
    });
};
const de_CertificateDescription = (output, context) => {
    return take(output, {
        caCertificateId: __expectString,
        certificateArn: __expectString,
        certificateId: __expectString,
        certificateMode: __expectString,
        certificatePem: __expectString,
        creationDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        customerVersion: __expectInt32,
        generationId: __expectString,
        lastModifiedDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        ownedBy: __expectString,
        previousOwnedBy: __expectString,
        status: __expectString,
        transferData: (_) => de_TransferData(_, context),
        validity: (_) => de_CertificateValidity(_, context),
    });
};
const de_Certificates = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Certificate(entry, context);
    });
    return retVal;
};
const de_CertificateValidity = (output, context) => {
    return take(output, {
        notAfter: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        notBefore: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
    });
};
const de_CodeSigning = (output, context) => {
    return take(output, {
        awsSignerJobId: __expectString,
        customCodeSigning: (_) => de_CustomCodeSigning(_, context),
        startSigningJobParameter: _json,
    });
};
const de_CodeSigningSignature = (output, context) => {
    return take(output, {
        inlineDocument: context.base64Decoder,
    });
};
const de_CustomCodeSigning = (output, context) => {
    return take(output, {
        certificateChain: _json,
        hashAlgorithm: __expectString,
        signature: (_) => de_CodeSigningSignature(_, context),
        signatureAlgorithm: __expectString,
    });
};
const de_DetectMitigationActionExecution = (output, context) => {
    return take(output, {
        actionName: __expectString,
        errorCode: __expectString,
        executionEndDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        executionStartDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        message: __expectString,
        status: __expectString,
        taskId: __expectString,
        thingName: __expectString,
        violationId: __expectString,
    });
};
const de_DetectMitigationActionExecutionList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_DetectMitigationActionExecution(entry, context);
    });
    return retVal;
};
const de_DetectMitigationActionsTaskSummary = (output, context) => {
    return take(output, {
        actionsDefinition: _json,
        onlyActiveViolationsIncluded: __expectBoolean,
        suppressedAlertsIncluded: __expectBoolean,
        target: _json,
        taskEndTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        taskId: __expectString,
        taskStartTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        taskStatistics: _json,
        taskStatus: __expectString,
        violationEventOccurrenceRange: (_) => de_ViolationEventOccurrenceRange(_, context),
    });
};
const de_DetectMitigationActionsTaskSummaryList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_DetectMitigationActionsTaskSummary(entry, context);
    });
    return retVal;
};
const de_ExponentialRolloutRate = (output, context) => {
    return take(output, {
        baseRatePerMinute: __expectInt32,
        incrementFactor: __limitedParseDouble,
        rateIncreaseCriteria: _json,
    });
};
const de_Job = (output, context) => {
    return take(output, {
        abortConfig: (_) => de_AbortConfig(_, context),
        comment: __expectString,
        completedAt: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        createdAt: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        description: __expectString,
        destinationPackageVersions: _json,
        documentParameters: _json,
        forceCanceled: __expectBoolean,
        isConcurrent: __expectBoolean,
        jobArn: __expectString,
        jobExecutionsRetryConfig: _json,
        jobExecutionsRolloutConfig: (_) => de_JobExecutionsRolloutConfig(_, context),
        jobId: __expectString,
        jobProcessDetails: _json,
        jobTemplateArn: __expectString,
        lastUpdatedAt: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        namespaceId: __expectString,
        presignedUrlConfig: _json,
        reasonCode: __expectString,
        scheduledJobRollouts: _json,
        schedulingConfig: _json,
        status: __expectString,
        targetSelection: __expectString,
        targets: _json,
        timeoutConfig: _json,
    });
};
const de_JobExecution = (output, context) => {
    return take(output, {
        approximateSecondsBeforeTimedOut: __expectLong,
        executionNumber: __expectLong,
        forceCanceled: __expectBoolean,
        jobId: __expectString,
        lastUpdatedAt: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        queuedAt: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        startedAt: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        status: __expectString,
        statusDetails: _json,
        thingArn: __expectString,
        versionNumber: __expectLong,
    });
};
const de_JobExecutionsRolloutConfig = (output, context) => {
    return take(output, {
        exponentialRate: (_) => de_ExponentialRolloutRate(_, context),
        maximumPerMinute: __expectInt32,
    });
};
const de_JobExecutionSummary = (output, context) => {
    return take(output, {
        executionNumber: __expectLong,
        lastUpdatedAt: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        queuedAt: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        retryAttempt: __expectInt32,
        startedAt: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        status: __expectString,
    });
};
const de_JobExecutionSummaryForJob = (output, context) => {
    return take(output, {
        jobExecutionSummary: (_) => de_JobExecutionSummary(_, context),
        thingArn: __expectString,
    });
};
const de_JobExecutionSummaryForJobList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_JobExecutionSummaryForJob(entry, context);
    });
    return retVal;
};
const de_JobExecutionSummaryForThing = (output, context) => {
    return take(output, {
        jobExecutionSummary: (_) => de_JobExecutionSummary(_, context),
        jobId: __expectString,
    });
};
const de_JobExecutionSummaryForThingList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_JobExecutionSummaryForThing(entry, context);
    });
    return retVal;
};
const de_JobSummary = (output, context) => {
    return take(output, {
        completedAt: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        createdAt: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        isConcurrent: __expectBoolean,
        jobArn: __expectString,
        jobId: __expectString,
        lastUpdatedAt: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        status: __expectString,
        targetSelection: __expectString,
        thingGroupId: __expectString,
    });
};
const de_JobSummaryList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_JobSummary(entry, context);
    });
    return retVal;
};
const de_JobTemplateSummary = (output, context) => {
    return take(output, {
        createdAt: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        description: __expectString,
        jobTemplateArn: __expectString,
        jobTemplateId: __expectString,
    });
};
const de_JobTemplateSummaryList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_JobTemplateSummary(entry, context);
    });
    return retVal;
};
const de_MetricDatum = (output, context) => {
    return take(output, {
        timestamp: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        value: (_) => de_MetricValue(_, context),
    });
};
const de_MetricDatumList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_MetricDatum(entry, context);
    });
    return retVal;
};
const de_MetricValue = (output, context) => {
    return take(output, {
        cidrs: _json,
        count: __expectLong,
        number: __limitedParseDouble,
        numbers: (_) => de_NumberList(_, context),
        ports: _json,
        strings: _json,
    });
};
const de_MitigationActionIdentifier = (output, context) => {
    return take(output, {
        actionArn: __expectString,
        actionName: __expectString,
        creationDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
    });
};
const de_MitigationActionIdentifierList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_MitigationActionIdentifier(entry, context);
    });
    return retVal;
};
const de_NumberList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __limitedParseDouble(entry);
    });
    return retVal;
};
const de_OTAUpdateFile = (output, context) => {
    return take(output, {
        attributes: _json,
        codeSigning: (_) => de_CodeSigning(_, context),
        fileLocation: _json,
        fileName: __expectString,
        fileType: __expectInt32,
        fileVersion: __expectString,
    });
};
const de_OTAUpdateFiles = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_OTAUpdateFile(entry, context);
    });
    return retVal;
};
const de_OTAUpdateInfo = (output, context) => {
    return take(output, {
        additionalParameters: _json,
        awsIotJobArn: __expectString,
        awsIotJobId: __expectString,
        awsJobExecutionsRolloutConfig: (_) => de_AwsJobExecutionsRolloutConfig(_, context),
        awsJobPresignedUrlConfig: _json,
        creationDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        description: __expectString,
        errorInfo: _json,
        lastModifiedDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        otaUpdateArn: __expectString,
        otaUpdateFiles: (_) => de_OTAUpdateFiles(_, context),
        otaUpdateId: __expectString,
        otaUpdateStatus: __expectString,
        protocols: _json,
        targetSelection: __expectString,
        targets: _json,
    });
};
const de_OTAUpdatesSummary = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_OTAUpdateSummary(entry, context);
    });
    return retVal;
};
const de_OTAUpdateSummary = (output, context) => {
    return take(output, {
        creationDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        otaUpdateArn: __expectString,
        otaUpdateId: __expectString,
    });
};
const de_OutgoingCertificate = (output, context) => {
    return take(output, {
        certificateArn: __expectString,
        certificateId: __expectString,
        creationDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        transferDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        transferMessage: __expectString,
        transferredTo: __expectString,
    });
};
const de_OutgoingCertificates = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_OutgoingCertificate(entry, context);
    });
    return retVal;
};
const de_PackageSummary = (output, context) => {
    return take(output, {
        creationDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        defaultVersionName: __expectString,
        lastModifiedDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        packageName: __expectString,
    });
};
const de_PackageSummaryList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_PackageSummary(entry, context);
    });
    return retVal;
};
const de_PackageVersionSummary = (output, context) => {
    return take(output, {
        creationDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        lastModifiedDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        packageName: __expectString,
        status: __expectString,
        versionName: __expectString,
    });
};
const de_PackageVersionSummaryList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_PackageVersionSummary(entry, context);
    });
    return retVal;
};
const de_Percentiles = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_PercentPair(entry, context);
    });
    return retVal;
};
const de_PercentPair = (output, context) => {
    return take(output, {
        percent: __limitedParseDouble,
        value: __limitedParseDouble,
    });
};
const de_PolicyVersion = (output, context) => {
    return take(output, {
        createDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        isDefaultVersion: __expectBoolean,
        versionId: __expectString,
    });
};
const de_PolicyVersions = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_PolicyVersion(entry, context);
    });
    return retVal;
};
const de_ProvisioningTemplateListing = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ProvisioningTemplateSummary(entry, context);
    });
    return retVal;
};
const de_ProvisioningTemplateSummary = (output, context) => {
    return take(output, {
        creationDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        description: __expectString,
        enabled: __expectBoolean,
        lastModifiedDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        templateArn: __expectString,
        templateName: __expectString,
        type: __expectString,
    });
};
const de_ProvisioningTemplateVersionListing = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ProvisioningTemplateVersionSummary(entry, context);
    });
    return retVal;
};
const de_ProvisioningTemplateVersionSummary = (output, context) => {
    return take(output, {
        creationDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        isDefaultVersion: __expectBoolean,
        versionId: __expectInt32,
    });
};
const de_RoleAliasDescription = (output, context) => {
    return take(output, {
        creationDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        credentialDurationSeconds: __expectInt32,
        lastModifiedDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        owner: __expectString,
        roleAlias: __expectString,
        roleAliasArn: __expectString,
        roleArn: __expectString,
    });
};
const de_Statistics = (output, context) => {
    return take(output, {
        average: __limitedParseDouble,
        count: __expectInt32,
        maximum: __limitedParseDouble,
        minimum: __limitedParseDouble,
        stdDeviation: __limitedParseDouble,
        sum: __limitedParseDouble,
        sumOfSquares: __limitedParseDouble,
        variance: __limitedParseDouble,
    });
};
const de_StreamInfo = (output, context) => {
    return take(output, {
        createdAt: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        description: __expectString,
        files: _json,
        lastUpdatedAt: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        roleArn: __expectString,
        streamArn: __expectString,
        streamId: __expectString,
        streamVersion: __expectInt32,
    });
};
const de_ThingGroupMetadata = (output, context) => {
    return take(output, {
        creationDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        parentGroupName: __expectString,
        rootToParentThingGroups: _json,
    });
};
const de_ThingTypeDefinition = (output, context) => {
    return take(output, {
        thingTypeArn: __expectString,
        thingTypeMetadata: (_) => de_ThingTypeMetadata(_, context),
        thingTypeName: __expectString,
        thingTypeProperties: _json,
    });
};
const de_ThingTypeList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ThingTypeDefinition(entry, context);
    });
    return retVal;
};
const de_ThingTypeMetadata = (output, context) => {
    return take(output, {
        creationDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        deprecated: __expectBoolean,
        deprecationDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
    });
};
const de_TopicRule = (output, context) => {
    return take(output, {
        actions: _json,
        awsIotSqlVersion: __expectString,
        createdAt: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        description: __expectString,
        errorAction: _json,
        ruleDisabled: __expectBoolean,
        ruleName: __expectString,
        sql: __expectString,
    });
};
const de_TopicRuleDestination = (output, context) => {
    return take(output, {
        arn: __expectString,
        createdAt: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        httpUrlProperties: _json,
        lastUpdatedAt: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        status: __expectString,
        statusReason: __expectString,
        vpcProperties: _json,
    });
};
const de_TopicRuleDestinationSummaries = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_TopicRuleDestinationSummary(entry, context);
    });
    return retVal;
};
const de_TopicRuleDestinationSummary = (output, context) => {
    return take(output, {
        arn: __expectString,
        createdAt: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        httpUrlSummary: _json,
        lastUpdatedAt: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        status: __expectString,
        statusReason: __expectString,
        vpcDestinationSummary: _json,
    });
};
const de_TopicRuleList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_TopicRuleListItem(entry, context);
    });
    return retVal;
};
const de_TopicRuleListItem = (output, context) => {
    return take(output, {
        createdAt: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        ruleArn: __expectString,
        ruleDisabled: __expectBoolean,
        ruleName: __expectString,
        topicPattern: __expectString,
    });
};
const de_TransferData = (output, context) => {
    return take(output, {
        acceptDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        rejectDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        rejectReason: __expectString,
        transferDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        transferMessage: __expectString,
    });
};
const de_ViolationEvent = (output, context) => {
    return take(output, {
        behavior: (_) => de_Behavior(_, context),
        metricValue: (_) => de_MetricValue(_, context),
        securityProfileName: __expectString,
        thingName: __expectString,
        verificationState: __expectString,
        verificationStateDescription: __expectString,
        violationEventAdditionalInfo: _json,
        violationEventTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        violationEventType: __expectString,
        violationId: __expectString,
    });
};
const de_ViolationEventOccurrenceRange = (output, context) => {
    return take(output, {
        endTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        startTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
    });
};
const de_ViolationEvents = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ViolationEvent(entry, context);
    });
    return retVal;
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});
const collectBodyString = (streamBody, context) => collectBody(streamBody, context).then((body) => context.utf8Encoder(body));
const isSerializableHeaderValue = (value) => value !== undefined &&
    value !== null &&
    value !== "" &&
    (!Object.getOwnPropertyNames(value).includes("length") || value.length != 0) &&
    (!Object.getOwnPropertyNames(value).includes("size") || value.size != 0);
const _aAR = "allowAutoRegistration";
const _aN = "attributeName";
const _aO = "ascendingOrder";
const _aS = "actionStatus";
const _aT = "actionType";
const _aTI = "auditTaskId";
const _aV = "attributeValue";
const _bCT = "behaviorCriteriaType";
const _cI = "clientId";
const _cT = "clientToken";
const _dN = "dimensionName";
const _dS = "deleteStream";
const _dSA = "deleteScheduledAudits";
const _dVO = "dimensionValueOperator";
const _eN = "executionNumber";
const _eT = "endpointType";
const _eTn = "endTime";
const _eV = "expectedVersion";
const _f = "force";
const _fD = "forceDelete";
const _fDAWSJ = "forceDeleteAWSJob";
const _fI = "findingId";
const _iAO = "isAscendingOrder";
const _jI = "jobId";
const _lSA = "listSuppressedAlerts";
const _m = "marker";
const _mN = "metricName";
const _mR = "maxResults";
const _nARS = "newAutoRegistrationStatus";
const _nI = "namespaceId";
const _nPF = "namePrefixFilter";
const _nS = "newStatus";
const _nT = "nextToken";
const _oUS = "otaUpdateStatus";
const _p = "principal";
const _pG = "parentGroup";
const _pN = "policyName";
const _pS = "pageSize";
const _r = "recursive";
const _rA = "resourceArn";
const _rD = "ruleDisabled";
const _rT = "reportType";
const _s = "status";
const _sAA = "setAsActive";
const _sAD = "setAsDefault";
const _sPN = "securityProfileName";
const _sPTA = "securityProfileTargetArn";
const _sT = "startTime";
const _sTe = "serviceType";
const _t = "tags";
const _tAA = "targetAwsAccount";
const _tGI = "thingGroupId";
const _tGN = "thingGroupName";
const _tI = "taskId";
const _tN = "targetName";
const _tNe = "templateName";
const _tNh = "thingName";
const _tS = "taskStatus";
const _tSa = "targetSelection";
const _tT = "targetType";
const _tTN = "thingTypeName";
const _tTa = "taskType";
const _tV = "templateVersion";
const _to = "topic";
const _uPAV = "usePrefixAttributeValue";
const _vI = "violationId";
const _vS = "verificationState";
const _xaip = "x-amzn-iot-principal";
const _xaip_ = "x-amzn-iot-policy";
const _xap = "x-amzn-principal";
const _xat = "x-amz-tagging";
const parseBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
        return JSON.parse(encoded);
    }
    return {};
});
const parseErrorBody = async (errorBody, context) => {
    const value = await parseBody(errorBody, context);
    value.message = value.message ?? value.Message;
    return value;
};
const loadRestJsonErrorCode = (output, data) => {
    const findKey = (object, key) => Object.keys(object).find((k) => k.toLowerCase() === key.toLowerCase());
    const sanitizeErrorCode = (rawValue) => {
        let cleanValue = rawValue;
        if (typeof cleanValue === "number") {
            cleanValue = cleanValue.toString();
        }
        if (cleanValue.indexOf(",") >= 0) {
            cleanValue = cleanValue.split(",")[0];
        }
        if (cleanValue.indexOf(":") >= 0) {
            cleanValue = cleanValue.split(":")[0];
        }
        if (cleanValue.indexOf("#") >= 0) {
            cleanValue = cleanValue.split("#")[1];
        }
        return cleanValue;
    };
    const headerKey = findKey(output.headers, "x-amzn-errortype");
    if (headerKey !== undefined) {
        return sanitizeErrorCode(output.headers[headerKey]);
    }
    if (data.code !== undefined) {
        return sanitizeErrorCode(data.code);
    }
    if (data["__type"] !== undefined) {
        return sanitizeErrorCode(data["__type"]);
    }
};
